<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Compression Hypothesis: Interactive Black Hole</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000002 70%);
            color: #e0e0ff;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(220, 220, 255, 0.9);
            font-size: 24px;
            letter-spacing: 0.5px;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
        }
        .subtitle {
            font-size: 16px;
            opacity: 0.8;
            margin-top: 10px;
        }
        .ui-panel {
            position: absolute;
            background-image: linear-gradient(145deg, rgba(20, 25, 45, 0.85), rgba(10, 15, 30, 0.9));
            backdrop-filter: blur(10px) saturate(160%);
            -webkit-backdrop-filter: blur(10px) saturate(160%);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(180, 180, 220, 0.15);
            color: rgba(225, 225, 255, 0.9);
            font-size: 14px;
            user-select: none;
            z-index: 50;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(180,180,220,0.07) inset;
        }
        #controls { 
            bottom: 20px; 
            right: 20px;
            animation: fadeIn 0.7s ease-out 0.5s both;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes subtlePulse {
            0%, 100% { 
                border-color: rgba(100, 150, 255, 0.3);
                box-shadow: 0 0 0 0 rgba(100, 150, 255, 0.2);
            }
            50% { 
                border-color: rgba(100, 150, 255, 0.5);
                box-shadow: 0 0 10px 2px rgba(100, 150, 255, 0.2);
            }
        }
        
        /* Interactive Elements */
        .interactive-element {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 40;
        }
        
        .interactive-element::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0; }
        }
        
        #particleIndicator {
            background: radial-gradient(circle, rgba(100, 200, 255, 0.6), rgba(50, 150, 255, 0.2));
            border: 2px solid rgba(100, 200, 255, 0.8);
        }
        #particleIndicator::before {
            background: radial-gradient(circle, rgba(100, 200, 255, 0.4), transparent);
        }
        
        #timeIndicator {
            background: radial-gradient(circle, rgba(255, 200, 100, 0.6), rgba(255, 150, 50, 0.2));
            border: 2px solid rgba(255, 200, 100, 0.8);
        }
        #timeIndicator::before {
            background: radial-gradient(circle, rgba(255, 200, 100, 0.4), transparent);
        }
        
        #gravityIndicator {
            background: radial-gradient(circle, rgba(200, 100, 255, 0.6), rgba(150, 50, 255, 0.2));
            border: 2px solid rgba(200, 100, 255, 0.8);
        }
        #gravityIndicator::before {
            background: radial-gradient(circle, rgba(200, 100, 255, 0.4), transparent);
        }
        
        #spaceIndicator {
            background: radial-gradient(circle, rgba(100, 255, 200, 0.6), rgba(50, 255, 150, 0.2));
            border: 2px solid rgba(100, 255, 200, 0.8);
        }
        #spaceIndicator::before {
            background: radial-gradient(circle, rgba(100, 255, 200, 0.4), transparent);
        }
        
        .interactive-element:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px currentColor;
        }
        
        .icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
        }
        
        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(10, 15, 30, 0.95);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 14px;
            line-height: 1.5;
            max-width: 250px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            z-index: 200;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .tooltip h4 {
            margin: 0 0 8px 0;
            color: #fff;
            font-size: 16px;
        }
        
        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: modalFadeIn 0.3s ease;
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal-content {
            background: linear-gradient(145deg, rgba(20, 25, 45, 0.98), rgba(10, 15, 30, 0.98));
            border: 1px solid rgba(100, 150, 255, 0.2);
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            animation: modalSlideIn 0.3s ease;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }
        
        @keyframes modalSlideIn {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .modal-content h2 {
            margin: 0 0 20px 0;
            color: #fff;
            font-size: 28px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .modal-content .icon-large {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .modal-content p {
            line-height: 1.8;
            color: rgba(225, 225, 255, 0.9);
            margin-bottom: 16px;
        }
        
        .modal-content .formula {
            background: rgba(0, 0, 0, 0.4);
            border-left: 3px solid #4285f4;
            padding: 16px 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 8px;
        }
        
        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s ease;
        }
        
        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(90deg);
        }
        
        /* Distance indicator */
        #distanceIndicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 15, 30, 0.9);
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 15px;
            padding: 12px 20px;
            font-size: 14px;
            z-index: 90;
            animation: fadeIn 0.7s ease-out 1s both, subtlePulse 3s ease-in-out 2s infinite;
            cursor: pointer;
            transition: all 0.3s ease;
            max-width: 480px;
        }
        
        #distanceIndicator:hover {
            background: rgba(10, 15, 35, 0.95);
            border-color: rgba(100, 150, 255, 0.5);
            box-shadow: 0 4px 20px rgba(100, 150, 255, 0.2);
        }
        
        .distance-main {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .distance-main::after {
            content: '▼';
            font-size: 10px;
            opacity: 0.6;
            transition: transform 0.3s ease;
        }
        
        #distanceIndicator:hover .distance-main::after {
            transform: translateY(2px);
        }
        
        .distance-explanation {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(100, 150, 255, 0.2);
            font-size: 12px;
            line-height: 1.5;
            color: rgba(225, 225, 255, 0.8);
            min-height: 20px;
        }
        
        .highlight {
            color: #4285f4;
            font-weight: 600;
        }
        
        /* Event Horizon Modal */
        #eventHorizonModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 1) 100%);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: horizonFadeIn 1s ease;
        }
        
        @keyframes horizonFadeIn {
            from { 
                opacity: 0;
                background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0) 100%);
            }
            to { 
                opacity: 1;
                background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.95) 0%, rgba(0, 0, 0, 1) 100%);
            }
        }
        
        .horizon-content {
            background: rgba(10, 15, 30, 0.98);
            border: 2px solid #ff3333;
            border-radius: 20px;
            padding: 40px;
            max-width: 700px;
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
            animation: horizonContentSlide 0.8s ease 0.5s both;
            box-shadow: 
                0 0 100px rgba(255, 51, 51, 0.5),
                0 0 50px rgba(255, 51, 51, 0.3) inset;
        }
        
        @keyframes horizonContentSlide {
            from { 
                transform: translateY(100px) scale(0.9); 
                opacity: 0;
            }
            to { 
                transform: translateY(0) scale(1); 
                opacity: 1;
            }
        }
        
        .horizon-content h2 {
            color: #ff6666;
            font-size: 32px;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 102, 102, 0.5);
        }
        
        .horizon-content .warning-box {
            background: rgba(255, 51, 51, 0.1);
            border: 1px solid rgba(255, 51, 51, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            font-size: 18px;
            color: #ff9999;
        }
        
        .horizon-content .formula-box {
            background: rgba(0, 0, 0, 0.5);
            border-left: 3px solid #ff3333;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            border-radius: 8px;
            color: #ffcccc;
        }
        
        .horizon-content p {
            line-height: 1.8;
            color: rgba(225, 225, 255, 0.95);
            margin-bottom: 16px;
            font-size: 16px;
        }
        
        .horizon-content .continue-btn {
            background: linear-gradient(45deg, #ff3333, #ff6666);
            border: none;
            border-radius: 30px;
            color: white;
            padding: 15px 40px;
            font-size: 18px;
            cursor: pointer;
            margin: 20px auto;
            display: block;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(255, 51, 51, 0.3);
        }
        
        .horizon-content .continue-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(255, 51, 51, 0.5);
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .interactive-element {
                width: 50px;
                height: 50px;
            }
            .icon {
                font-size: 20px;
            }
            .modal-content {
                padding: 24px;
                margin: 20px;
            }
            .modal-content h2 {
                font-size: 24px;
            }
            #info {
                font-size: 20px;
            }
            .subtitle {
                font-size: 14px;
            }
            .horizon-content {
                padding: 24px;
                margin: 20px;
            }
            .horizon-content h2 {
                font-size: 24px;
            }
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
      }
    }
    </script>
</head>
<body>

<div id="info">
    The Compression Hypothesis
    <div class="subtitle">Click the glowing indicators to explore how reality compresses near a black hole</div>
</div>

<div id="distanceIndicator">
    <div class="distance-main">
        Distance from Event Horizon: <span id="distanceValue" class="highlight">10.0 Rs</span>
    </div>
    <div id="distanceExplanation" class="distance-explanation">
        <!-- Dynamic explanation will be inserted here -->
    </div>
</div>

<div id="controls" class="ui-panel">
    <div id="autoRotateToggle" style="cursor: pointer; padding: 8px;">
        <span>Auto-Rotate: OFF</span>
    </div>
</div>

<!-- Interactive Elements -->
<div id="particleIndicator" class="interactive-element" style="left: 100px; top: 200px;">
    <div class="icon">⚛️</div>
</div>

<div id="timeIndicator" class="interactive-element" style="right: 100px; top: 200px;">
    <div class="icon">⏱️</div>
</div>

<div id="gravityIndicator" class="interactive-element" style="left: 100px; bottom: 200px;">
    <div class="icon">🌀</div>
</div>

<div id="spaceIndicator" class="interactive-element" style="right: 100px; bottom: 200px;">
    <div class="icon">📐</div>
</div>

<!-- Tooltip -->
<div id="tooltip" class="tooltip"></div>

<!-- Modal -->
<div id="modal" class="modal">
    <div class="modal-content">
        <div class="close-btn" onclick="closeModal()">✕</div>
        <div id="modalContent"></div>
    </div>
</div>

<!-- Event Horizon Modal -->
<div id="eventHorizonModal">
    <div class="horizon-content">
        <h2>⚠️ APPROACHING THE EVENT HORIZON ⚠️</h2>
        
        <div class="warning-box">
            You are at the boundary where 3D reality ceases to exist
        </div>
        
        <p><strong>What's happening at this distance:</strong></p>
        
        <div class="formula-box">
            Distance: <span id="horizonDistance">1.4</span> Rs<br>
            Information Loss: <span id="horizonCompression">93%</span><br>
            Time Dilation: <span id="horizonTime">7%</span> of normal<br>
            Reality Status: CRITICAL FAILURE
        </div>
        
        <p>You've reached the limit of what can be visualized in 3D space. Beyond this point, the Compression Hypothesis reveals that:</p>
        
        <p><strong>🌀 Spacetime Breakdown:</strong><br>
        The metric tensor becomes singular. The universe's ability to maintain coherent 3D coordinates completely fails. What you're seeing now is the last frame of reality before total information collapse.</p>
        
        <p><strong>⏱️ Time Cessation:</strong><br>
        Time isn't just slowing—it's approaching zero. From your perspective, the universe outside is accelerating to infinite speed. You're witnessing eternity in an instant.</p>
        
        <p><strong>📊 Information Paradox:</strong><br>
        The Linear Signal Loss theory shows that at exactly 1.0 Rs, both gravitational and electromagnetic information channels reach 100% degradation simultaneously. This is why nothing can escape—there's literally no "signal" left to carry information outward.</p>
        
        <p><strong>🔴 The Holographic Transition:</strong><br>
        What happens next cannot be shown in 3D because it doesn't exist in 3D. All information about anything crossing the horizon gets encoded on the 2D surface. You don't fall "into" the black hole—you become part of its surface information.</p>
        
        <div class="formula-box">
            Final Compression: 3D → 2D<br>
            Information Density: Maximum (Planck scale)<br>
            Degrees of Freedom: M, Q, J only
        </div>
        
        <p><strong>From the Compression Hypothesis perspective:</strong><br>
        The event horizon is where the universe admits defeat. It cannot compress the information any further while maintaining its original structure. Like a file compressed beyond recognition, what emerges on the other side (if anything) bears no resemblance to what went in.</p>
        
        <p>The visualization cannot proceed further because there is no "further" in any meaningful 3D sense. The compression is complete. The information that was "you" now exists only as a contribution to the black hole's mass, charge, and angular momentum.</p>
        
        <button class="continue-btn" onclick="closeEventHorizonModal()">Return to Observable Reality</button>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

    const BLACK_HOLE_RADIUS = 1.3;
    const DISK_INNER_RADIUS = BLACK_HOLE_RADIUS + 0.2;
    const DISK_OUTER_RADIUS = 8.0;
    const DISK_TILT_ANGLE = Math.PI / 3.0;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x020104, 0.025);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
    camera.position.set(-6.5, 5.0, 6.5);
    window.camera = camera; // Expose globally for modal access

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.body.appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    
    const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.8, 0.7, 0.8
    );
    composer.addPass(bloomPass);

    const lensingShader = {
        uniforms: {
            "tDiffuse": { value: null },
            "blackHoleScreenPos": { value: new THREE.Vector2(0.5, 0.5) },
            "lensingStrength": { value: 0.12 },
            "lensingRadius": { value: 0.3 },
            "aspectRatio": { value: window.innerWidth / window.innerHeight },
            "chromaticAberration": { value: 0.005 }
        },
        vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
        fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform vec2 blackHoleScreenPos;
            uniform float lensingStrength;
            uniform float lensingRadius;
            uniform float aspectRatio;
            uniform float chromaticAberration;
            varying vec2 vUv;
            
            void main() {
                vec2 screenPos = vUv;
                vec2 toCenter = screenPos - blackHoleScreenPos;
                toCenter.x *= aspectRatio;
                float dist = length(toCenter);
                
                float distortionAmount = lensingStrength / (dist * dist + 0.003);
                distortionAmount = clamp(distortionAmount, 0.0, 0.7);
                float falloff = smoothstep(lensingRadius, lensingRadius * 0.3, dist);
                distortionAmount *= falloff;
                
                vec2 offset = normalize(toCenter) * distortionAmount;
                offset.x /= aspectRatio;
                
                vec2 distortedUvR = screenPos - offset * (1.0 + chromaticAberration);
                vec2 distortedUvG = screenPos - offset;
                vec2 distortedUvB = screenPos - offset * (1.0 - chromaticAberration);
                
                float r = texture2D(tDiffuse, distortedUvR).r;
                float g = texture2D(tDiffuse, distortedUvG).g;
                float b = texture2D(tDiffuse, distortedUvB).b;
                
                gl_FragColor = vec4(r, g, b, 1.0);
            }`
    };
    const lensingPass = new ShaderPass(lensingShader);
    composer.addPass(lensingPass);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; 
    controls.dampingFactor = 0.035;
    controls.rotateSpeed = 0.4; 
    controls.autoRotate = false;
    controls.autoRotateSpeed = 0.1;
    controls.target.set(0, 0, 0);
    controls.minDistance = 1.35; // Allow approach to just above event horizon
    controls.maxDistance = 100;
    controls.enablePan = false;
    controls.update();
    window.controls = controls; // Expose globally for modal access
    window.BLACK_HOLE_RADIUS = BLACK_HOLE_RADIUS; // Expose globally

    // Auto-rotate toggle
    let autoRotateEnabled = false;
    const autoRotateToggle = document.getElementById('autoRotateToggle');
    autoRotateToggle.addEventListener('click', () => {
        autoRotateEnabled = !autoRotateEnabled;
        controls.autoRotate = autoRotateEnabled;
        autoRotateToggle.innerHTML = `<span>Auto-Rotate: ${autoRotateEnabled ? "ON" : "OFF"}</span>`;
    });

    // Star field
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 150000;
    const starPositions = new Float32Array(starCount * 3);
    const starColors = new Float32Array(starCount * 3);
    const starSizes = new Float32Array(starCount);
    const starTwinkle = new Float32Array(starCount);
    const starFieldRadius = 2000;

    for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        const phi = Math.acos(-1 + (2 * i) / starCount);
        const theta = Math.sqrt(starCount * Math.PI) * phi;
        const radius = Math.cbrt(Math.random()) * starFieldRadius + 100;

        starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        starPositions[i3 + 2] = radius * Math.cos(phi);

        const colorChoice = Math.random();
        if (colorChoice < 0.33) {
            starColors[i3] = 0.8 + Math.random() * 0.2;
            starColors[i3 + 1] = 0.8 + Math.random() * 0.2;
            starColors[i3 + 2] = 1.0;
        } else if (colorChoice < 0.66) {
            starColors[i3] = 1.0;
            starColors[i3 + 1] = 0.9 + Math.random() * 0.1;
            starColors[i3 + 2] = 0.8 + Math.random() * 0.2;
        } else {
            starColors[i3] = 1.0;
            starColors[i3 + 1] = 0.8 + Math.random() * 0.2;
            starColors[i3 + 2] = 0.8 + Math.random() * 0.2;
        }
        
        starSizes[i] = THREE.MathUtils.randFloat(0.6, 3.0);
        starTwinkle[i] = Math.random() * Math.PI * 2;
    }

    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
    starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
    starGeometry.setAttribute('twinkle', new THREE.BufferAttribute(starTwinkle, 1));

    const starMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uPixelRatio: { value: renderer.getPixelRatio() }
        },
        vertexShader: `
            uniform float uTime;
            uniform float uPixelRatio;
            attribute float size;
            attribute float twinkle;
            varying vec3 vColor;
            varying float vTwinkle;
            
            void main() {
                vColor = color;
                vTwinkle = sin(uTime * 2.5 + twinkle) * 0.5 + 0.5;
                
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_PointSize = size * uPixelRatio * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            varying vec3 vColor;
            varying float vTwinkle;
            
            void main() {
                float dist = distance(gl_PointCoord, vec2(0.5));
                if (dist > 0.5) discard;
                
                float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                alpha *= (0.2 + vTwinkle * 0.8);
                
                gl_FragColor = vec4(vColor, alpha);
            }
        `,
        transparent: true,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Event horizon
    const eventHorizonGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS * 1.05, 128, 64);
    const eventHorizonMat = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uCameraPosition: { value: camera.position }
        },
        vertexShader: `
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float uTime;
            uniform vec3 uCameraPosition;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                vec3 viewDirection = normalize(uCameraPosition - vPosition);
                float fresnel = 1.0 - abs(dot(vNormal, viewDirection));
                fresnel = pow(fresnel, 2.5);
                
                vec3 glowColor = vec3(1.0, 0.4, 0.1);
                float pulse = sin(uTime * 2.5) * 0.15 + 0.85;
                
                gl_FragColor = vec4(glowColor * fresnel * pulse, fresnel * 0.4);
            }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide
    });

    const eventHorizon = new THREE.Mesh(eventHorizonGeom, eventHorizonMat);
    scene.add(eventHorizon);

    // Black hole
    const blackHoleGeom = new THREE.SphereGeometry(BLACK_HOLE_RADIUS, 128, 64);
    const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
    const blackHoleMesh = new THREE.Mesh(blackHoleGeom, blackHoleMat);
    blackHoleMesh.renderOrder = 0;
    scene.add(blackHoleMesh);

    // Accretion disk
    const diskGeometry = new THREE.RingGeometry(DISK_INNER_RADIUS, DISK_OUTER_RADIUS, 256, 128);
    const diskMaterial = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0.0 },
            uColorHot: { value: new THREE.Color(0xffffff) },
            uColorMid1: { value: new THREE.Color(0xff7733) },
            uColorMid2: { value: new THREE.Color(0xff4477) },
            uColorMid3: { value: new THREE.Color(0x7744ff) },
            uColorOuter: { value: new THREE.Color(0x4477ff) },
            uNoiseScale: { value: 2.5 },
            uFlowSpeed: { value: 0.22 },
            uDensity: { value: 1.3 }
        },
        vertexShader: `
            varying vec2 vUv;
            varying float vRadius;
            varying float vAngle;
            void main() {
                vUv = uv;
                vRadius = length(position.xy);
                vAngle = atan(position.y, position.x);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform float uTime;
            uniform vec3 uColorHot;
            uniform vec3 uColorMid1;
            uniform vec3 uColorMid2;
            uniform vec3 uColorMid3;
            uniform vec3 uColorOuter;
            uniform float uNoiseScale;
            uniform float uFlowSpeed;
            uniform float uDensity;

            varying vec2 vUv;
            varying float vRadius;
            varying float vAngle;

            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            
            float snoise(vec3 v) {
                const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i);
                vec4 p = permute( permute( permute( 
                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                       + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                       + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857;
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                float normalizedRadius = smoothstep(${DISK_INNER_RADIUS.toFixed(2)}, ${DISK_OUTER_RADIUS.toFixed(2)}, vRadius);
                
                float spiral = vAngle * 3.0 - (1.0 / (normalizedRadius + 0.1)) * 2.0;
                vec2 noiseUv = vec2(vUv.x + uTime * uFlowSpeed * (2.0 / (vRadius * 0.3 + 1.0)) + sin(spiral) * 0.1, vUv.y * 0.8 + cos(spiral) * 0.1);
                float noiseVal1 = snoise(vec3(noiseUv * uNoiseScale, uTime * 0.15));
                float noiseVal2 = snoise(vec3(noiseUv * uNoiseScale * 3.0 + 0.8, uTime * 0.22));
                float noiseVal3 = snoise(vec3(noiseUv * uNoiseScale * 6.0 + 1.5, uTime * 0.3));
                
                float noiseVal = (noiseVal1 * 0.45 + noiseVal2 * 0.35 + noiseVal3 * 0.2);
                noiseVal = (noiseVal + 1.0) * 0.5;
                
                vec3 color = uColorOuter;
                color = mix(color, uColorMid3, smoothstep(0.0, 0.25, normalizedRadius));
                color = mix(color, uColorMid2, smoothstep(0.2, 0.55, normalizedRadius));
                color = mix(color, uColorMid1, smoothstep(0.5, 0.75, normalizedRadius));
                color = mix(color, uColorHot, smoothstep(0.7, 0.95, normalizedRadius));
                
                color *= (0.5 + noiseVal * 1.0);
                float brightness = pow(1.0 - normalizedRadius, 1.0) * 3.5 + 0.5;
                brightness *= (0.3 + noiseVal * 2.2);
                
                float pulse = sin(uTime * 1.8 + normalizedRadius * 12.0 + vAngle * 2.0) * 0.15 + 0.85;
                brightness *= pulse;
                
                float alpha = uDensity * (0.2 + noiseVal * 0.9);
                alpha *= smoothstep(0.0, 0.15, normalizedRadius);
                alpha *= (1.0 - smoothstep(0.85, 1.0, normalizedRadius));
                alpha = clamp(alpha, 0.0, 1.0);

                gl_FragColor = vec4(color * brightness, alpha);
            }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
    accretionDisk.rotation.x = DISK_TILT_ANGLE;
    accretionDisk.renderOrder = 1;
    scene.add(accretionDisk);

    // Animation
    const clock = new THREE.Clock();
    const blackHoleScreenPosVec3 = new THREE.Vector3();
    let hasShownEventHorizonModal = false;
    let lastDistance = 10.0;
    
    function animate() {
        requestAnimationFrame(animate);
        const elapsedTime = clock.getElapsedTime();
        const deltaTime = clock.getDelta();

        diskMaterial.uniforms.uTime.value = elapsedTime;
        starMaterial.uniforms.uTime.value = elapsedTime;
        eventHorizonMat.uniforms.uTime.value = elapsedTime;
        eventHorizonMat.uniforms.uCameraPosition.value.copy(camera.position);

        blackHoleScreenPosVec3.copy(blackHoleMesh.position).project(camera);
        lensingPass.uniforms.blackHoleScreenPos.value.set(
            (blackHoleScreenPosVec3.x + 1) / 2,
            (blackHoleScreenPosVec3.y + 1) / 2
        );

        controls.update();
        
        stars.rotation.y += deltaTime * 0.003;
        stars.rotation.x += deltaTime * 0.001;

        accretionDisk.rotation.z += deltaTime * 0.005;

        // Update distance display
        const distance = camera.position.length();
        const schwarzschildRadii = (distance / BLACK_HOLE_RADIUS).toFixed(1);
        document.getElementById('distanceValue').textContent = `${schwarzschildRadii} Rs`;
        
        // Update distance explanation dynamically
        updateDistanceExplanation(parseFloat(schwarzschildRadii));
        
        // Visual effects near event horizon
        const horizonProximity = Math.max(0, Math.min(1, (2.0 - parseFloat(schwarzschildRadii)) / 0.5));
        if (horizonProximity > 0) {
            // Increase bloom intensity near horizon
            bloomPass.strength = 0.8 + horizonProximity * 0.7;
            // Increase chromatic aberration
            lensingPass.uniforms.chromaticAberration.value = 0.005 + horizonProximity * 0.02;
            // Darken the scene
            renderer.toneMappingExposure = 1.2 - horizonProximity * 0.4;
        } else {
            // Reset to defaults
            bloomPass.strength = 0.8;
            lensingPass.uniforms.chromaticAberration.value = 0.005;
            renderer.toneMappingExposure = 1.2;
        }
        
        // Check for event horizon approach
        if (parseFloat(schwarzschildRadii) <= 1.5 && !hasShownEventHorizonModal && lastDistance > 1.5) {
            window.showEventHorizonModal(parseFloat(schwarzschildRadii));
            hasShownEventHorizonModal = true;
        }
        
        // Reset flag if moving away
        if (parseFloat(schwarzschildRadii) > 3.0) {
            hasShownEventHorizonModal = false;
        }
        
        lastDistance = parseFloat(schwarzschildRadii);

        // Update interactive element positions
        updateElementPositions();

        composer.render(deltaTime);
    }

    // Update interactive element positions based on camera
    function updateElementPositions() {
        const elements = [
            { id: 'particleIndicator', offset: new THREE.Vector3(-3, 2, 0) },
            { id: 'timeIndicator', offset: new THREE.Vector3(3, 2, 0) },
            { id: 'gravityIndicator', offset: new THREE.Vector3(-3, -2, 0) },
            { id: 'spaceIndicator', offset: new THREE.Vector3(3, -2, 0) }
        ];

        elements.forEach(el => {
            const worldPos = blackHoleMesh.position.clone().add(el.offset);
            const screenPos = worldPos.project(camera);
            
            const element = document.getElementById(el.id);
            if (element) {
                element.style.left = `${(screenPos.x + 1) * window.innerWidth / 2}px`;
                element.style.top = `${(-screenPos.y + 1) * window.innerHeight / 2}px`;
            }
        });
    }

    animate();

    // Window resize handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        bloomPass.resolution.set(window.innerWidth, window.innerHeight);
        lensingPass.uniforms.aspectRatio.value = window.innerWidth / window.innerHeight;
    });
</script>

<script>
// Tooltip and modal data
const interactiveData = {
    distanceIndicator: {
        title: "Schwarzschild Radius (Rs)",
        hover: "Click to explore what Rs means and why distance matters",
        click: {
            title: "Understanding the Schwarzschild Radius",
            content: `
                <p>The <strong>Schwarzschild radius (Rs)</strong> is the critical boundary where the universe's compression algorithm reaches its limit. It's defined as:</p>
                
                <div class="formula">
                Rs = 2GM/c²<br>
                For our Sun: Rs ≈ 3 km<br>
                For Earth: Rs ≈ 9 mm
                </div>
                
                <p><strong>What Your Current Distance Means:</strong></p>
                
                <p>As you journey from far away toward the event horizon at Rs, reality undergoes a dramatic transformation through increasingly aggressive information compression:</p>
                
                <p><strong>▸ 100 Rs (Very Far):</strong><br>
                • Compression: ~1% - Nearly lossless<br>
                • Time dilation: Negligible (99.5% normal)<br>
                • Reality: Classical physics dominates<br>
                • Information: Easily decoded, stable orbits</p>
                
                <p><strong>▸ 50 Rs (Far):</strong><br>
                • Compression: ~2% - Minor effects visible<br>
                • Time dilation: 98% of normal<br>
                • Reality: Small relativistic corrections<br>
                • Information: High fidelity transmission</p>
                
                <p><strong>▸ 20 Rs (Approaching):</strong><br>
                • Compression: ~5% - Noticeable warping<br>
                • Time dilation: 95% of normal<br>
                • Reality: Curved spacetime evident<br>
                • Information: Beginning to degrade</p>
                
                <p><strong>▸ 10 Rs (Near):</strong><br>
                • Compression: ~10% - Significant effects<br>
                • Time dilation: 90% of normal<br>
                • Reality: Strong gravitational lensing<br>
                • Information: Compression artifacts appear</p>
                
                <p><strong>▸ 5 Rs (Close):</strong><br>
                • Compression: ~20% - Heavy distortion<br>
                • Time dilation: 77% of normal<br>
                • Reality: Quantum effects emerging<br>
                • Information: Major signal degradation</p>
                
                <p><strong>▸ 3 Rs (Very Close - Photon Sphere):</strong><br>
                • Compression: ~33% - Critical threshold<br>
                • Time dilation: 58% of normal<br>
                • Reality: Light orbits the black hole<br>
                • Information: Severe loss, unstable paths</p>
                
                <p><strong>▸ 2 Rs (Extremely Close):</strong><br>
                • Compression: ~50% - Half reality lost<br>
                • Time dilation: 41% of normal<br>
                • Reality: Breakdown of causality<br>
                • Information: Approaching encoding limit</p>
                
                <p><strong>▸ 1.5 Rs (Near Horizon):</strong><br>
                • Compression: ~67% - Critical failure<br>
                • Time dilation: 25% of normal<br>
                • Reality: Spacetime foam dominates<br>
                • Information: Extreme quantum noise</p>
                
                <p><strong>▸ 1.1 Rs (Just Above Horizon):</strong><br>
                • Compression: ~91% - Near total loss<br>
                • Time dilation: 10% of normal<br>
                • Reality: Information paradox regime<br>
                • Information: Holographic limit reached</p>
                
                <p><strong>▸ 1.0 Rs (Event Horizon):</strong><br>
                • Compression: 100% - Complete encoding<br>
                • Time dilation: 0% (time stops)<br>
                • Reality: 3D→2D holographic projection<br>
                • Information: Frozen on the surface</p>
                
                <p><strong>The Deeper Meaning:</strong><br>
                In the Compression Hypothesis, Rs isn't just where light can't escape—it's where the universe's ability to maintain coherent 3D reality completely fails. The "gravitational signal" that maintains particle trajectories, electromagnetic fields, and even time itself degrades to zero. Everything that falls in gets compressed onto the 2D horizon surface, achieving the ultimate data compression: an entire star reduced to just mass, charge, and spin.</p>
                
                <p><strong>Why Distance Matters:</strong><br>
                Your distance from Rs determines how much "compression loss" you experience. This isn't just metaphorical—our Linear Signal Loss theory shows that both gravity AND electromagnetism degrade proportionally as you approach Rs, revealing their unified information-theoretic nature. The black hole is quite literally where the universe says: "I cannot compress this information any further while maintaining its original form."</p>
            `
        }
    },
    particleIndicator: {
        title: "Particles",
        hover: "Particles lose coherent trajectories as the gravitational signal degrades into quantum noise near the event horizon.",
        click: {
            title: "Particle Behavior Near Black Holes",
            content: `
                <p>According to the <strong>Compression Hypothesis</strong>, particles are information packets that maintain coherent trajectories through spacetime. As you approach the event horizon, something remarkable happens:</p>
                
                <div class="formula">
                Signal Degradation: S(r) = (1 - γ·rs/r)<br>
                where γ measures information loss
                </div>
                
                <p><strong>Far from the black hole (r >> rs):</strong><br>
                Particles maintain classical, predictable paths. The gravitational "signal" is strong, allowing the universe to compress their quantum states into well-defined positions and momenta.</p>
                
                <p><strong>Near the event horizon (r → rs):</strong><br>
                The Linear Signal Loss model shows that as γ approaches 1, particles begin to "decohere." Their trajectories become increasingly uncertain, entering superposition states. This isn't just Heisenberg uncertainty—it's the breakdown of the compression algorithm itself.</p>
                
                <p><strong>Key Insight:</strong><br>
                The research found that when testing theories with signal degradation, both gravitational AND electromagnetic effects degrade proportionally. This suggests particles aren't just affected by gravity—they're losing their ability to be "decoded" from the quantum foam altogether.</p>
                
                <p><strong>At the horizon:</strong><br>
                Particles effectively cease to exist as distinct entities. They become part of the black hole's information content, encoded on the 2D surface rather than in 3D space—the ultimate compression.</p>
            `
        }
    },
    timeIndicator: {
        title: "Time",
        hover: "Time dilation becomes extreme as information processing slows down near the compression boundary.",
        click: {
            title: "Time and Information Processing",
            content: `
                <p>In the <strong>Compression Hypothesis</strong>, time isn't fundamental—it's the rate at which the universe processes and compresses information. Near a black hole, this rate changes dramatically:</p>
                
                <div class="formula">
                Time Dilation: dt/dτ = 1/√(1 - rs/r)<br>
                Information Processing Rate ∝ (1 - rs/r)
                </div>
                
                <p><strong>The Computational Perspective:</strong><br>
                Just as a computer slows down when processing complex calculations, spacetime requires more "computational resources" to maintain coherent reality near extreme mass concentrations.</p>
                
                <p><strong>From the research findings:</strong><br>
                The FFT analysis of orbital trajectories revealed that time dilation isn't just about clocks running slower—it's about the frequency spectrum of reality itself shifting. Orbits that should precess at specific rates show systematic frequency shifts that match the information processing slowdown.</p>
                
                <p><strong>At different distances:</strong></p>
                <p>• <strong>10 Rs:</strong> Time runs at ~30% normal speed<br>
                • <strong>2 Rs:</strong> Time runs at ~50% normal speed<br>
                • <strong>1.1 Rs:</strong> Time nearly stops (processing approaches zero)</p>
                
                <p><strong>The Deeper Truth:</strong><br>
                This isn't just relativistic time dilation—it's the universe allocating its "computational budget." Where gravity is strongest, maintaining even basic causality requires enormous information processing, leaving less capacity for time to "flow."</p>
            `
        }
    },
    gravityIndicator: {
        title: "Gravity",
        hover: "Gravity acts as the universe's compression algorithm, becoming increasingly aggressive near the event horizon.",
        click: {
            title: "Gravity as Information Compression",
            content: `
                <p>The <strong>Compression Hypothesis</strong> reframes gravity not as a force, but as the universe's method for compressing high-dimensional quantum information into stable, low-dimensional classical spacetime:</p>
                
                <div class="formula">
                Compression Gradient: ∇(Information Density) = 8πG·T_μν<br>
                Loss Function: L = ||r_predicted - r_truth||²
                </div>
                
                <p><strong>The Revolutionary Finding:</strong><br>
                When testing 69+ gravitational theories as "decoders," only General Relativity achieved zero loss—it's the only lossless compression algorithm for gravitational information. This isn't a coincidence; it suggests GR is the universe's actual compression scheme.</p>
                
                <p><strong>How compression intensifies near black holes:</strong></p>
                <p>• <strong>Weak field (r >> rs):</strong> Gentle compression, nearly linear<br>
                • <strong>Strong field (r ~ 3rs):</strong> Non-linear compression begins<br>
                • <strong>Near horizon (r → rs):</strong> Extreme compression, approaching infinite density</p>
                
                <p><strong>The Linear Signal Loss Discovery:</strong><br>
                The research introduced a model where gravitational "signal" degrades: g_tt = -(1 - γrs/r)(1 - rs/r). Remarkably, when γ=0.75, the loss against both gravitational AND electromagnetic baselines was nearly equal (0.153 vs 0.161), suggesting gravity and EM share the same compression infrastructure.</p>
                
                <p><strong>Black Holes as Ultimate Compressors:</strong><br>
                A black hole represents the limit of compression—reducing an entire star's information to just three numbers: mass, charge, and spin. The event horizon is where the compression becomes so extreme that no further information can escape the encoding process.</p>
            `
        }
    },
    spaceIndicator: {
        title: "Space",
        hover: "Spacetime geometry warps dramatically as the metric tensor struggles to encode information near the singularity.",
        click: {
            title: "Spacetime Metric and Information Encoding",
            content: `
                <p>In the <strong>Compression Hypothesis</strong>, the fabric of spacetime itself is the medium through which the universe encodes information. The metric tensor g_μν acts as the "codec" that determines how information is compressed and decoded:</p>
                
                <div class="formula">
                Schwarzschild Metric: ds² = -(1-rs/r)dt² + dr²/(1-rs/r) + r²dΩ²<br>
                Information Capacity ∝ Area (Holographic Principle)
                </div>
                
                <p><strong>What the research revealed about space:</strong><br>
                By testing how different metric modifications affect particle trajectories, the study found that even tiny changes to spacetime geometry cause massive trajectory deviations. The "Participatory" model, which was 92% GR and 8% flat space, showed catastrophic orbital decay—proving spacetime encoding is extremely fragile.</p>
                
                <p><strong>Near a black hole, space exhibits:</strong></p>
                <p>• <strong>Radial stretching:</strong> dr²/(1-rs/r) → ∞ as r → rs<br>
                • <strong>Angular compression:</strong> Circumference < 2πr<br>
                • <strong>Causal disconnection:</strong> Light cones tip beyond 45°</p>
                
                <p><strong>The Information Theoretic View:</strong><br>
                Space isn't empty—it's a dense information field. Near the event horizon, this field reaches maximum information density (the Bekenstein bound). The warping of space is literally the visualization of information compression gradients.</p>
                
                <p><strong>Key Discovery - Metric Sensitivity:</strong><br>
                The FFT analysis showed that orbital frequencies encode the complete metric structure. A theory with the wrong spatial curvature (g_rr) but correct time component (g_tt) still fails catastrophically—proving that space and time compression must be perfectly coordinated.</p>
                
                <p><strong>At the horizon:</strong><br>
                Space becomes so compressed that a finite proper distance maps to infinite coordinate distance—the ultimate information bottleneck where 3D space collapses onto a 2D surface.</p>
            `
        }
    }
};

// Tooltip functionality
const tooltip = document.getElementById('tooltip');
let currentTooltipTarget = null;

function showTooltip(element, data) {
    const rect = element.getBoundingClientRect();
    tooltip.innerHTML = `<h4>${data.title}</h4>${data.hover}`;
    
    // Position tooltip
    let left = rect.left + rect.width / 2 - 125; // Center tooltip
    let top = rect.bottom + 10;
    
    // Adjust if off-screen
    if (left < 10) left = 10;
    if (left + 250 > window.innerWidth - 10) left = window.innerWidth - 260;
    if (top + 100 > window.innerHeight) {
        top = rect.top - 100; // Show above if not enough space below
    }
    
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
    tooltip.classList.add('show');
    currentTooltipTarget = element;
}

function hideTooltip() {
    tooltip.classList.remove('show');
    currentTooltipTarget = null;
}

// Modal functionality
function showModal(data) {
    const modal = document.getElementById('modal');
    const modalContent = document.getElementById('modalContent');
    
    const iconColors = {
        distanceIndicator: 'background: rgba(66, 133, 244, 0.2); border: 2px solid rgba(66, 133, 244, 0.8);',
        particleIndicator: 'background: rgba(100, 200, 255, 0.2); border: 2px solid rgba(100, 200, 255, 0.8);',
        timeIndicator: 'background: rgba(255, 200, 100, 0.2); border: 2px solid rgba(255, 200, 100, 0.8);',
        gravityIndicator: 'background: rgba(200, 100, 255, 0.2); border: 2px solid rgba(200, 100, 255, 0.8);',
        spaceIndicator: 'background: rgba(100, 255, 200, 0.2); border: 2px solid rgba(100, 255, 200, 0.8);'
    };
    
    const icons = {
        distanceIndicator: '📏',
        particleIndicator: '⚛️',
        timeIndicator: '⏱️',
        gravityIndicator: '🌀',
        spaceIndicator: '📐'
    };
    
    modalContent.innerHTML = `
        <h2>
            <div class="icon-large" style="${iconColors[data.id]}">
                ${icons[data.id]}
            </div>
            ${data.click.title}
        </h2>
        ${data.click.content}
    `;
    
    modal.style.display = 'flex';
}

function closeModal() {
    document.getElementById('modal').style.display = 'none';
}

// Event Horizon Modal functions
window.showEventHorizonModal = function(currentRs) {
    const modal = document.getElementById('eventHorizonModal');
    
    // Calculate compression based on signal degradation (Linear Signal Loss model)
    // At Rs=1, compression is 100%; increases non-linearly as we approach
    const compressionPercent = Math.round(100 * (1 - 1/currentRs));
    
    // Calculate time dilation using Schwarzschild metric
    // dt/dτ = 1/√(1 - rs/r) where rs = 1 in our units
    const timeDilation = Math.round(100 * Math.sqrt(1 - 1/currentRs));
    
    // Update dynamic values
    document.getElementById('horizonDistance').textContent = currentRs.toFixed(1);
    document.getElementById('horizonCompression').textContent = compressionPercent + '%';
    document.getElementById('horizonTime').textContent = timeDilation + '%';
    
    // Show modal
    modal.style.display = 'flex';
    
    // Pause the simulation
    if (window.controls) {
        window.controls.autoRotate = false;
    }
}

function closeEventHorizonModal() {
    document.getElementById('eventHorizonModal').style.display = 'none';
    
    // Move camera back slightly
    if (window.camera && window.BLACK_HOLE_RADIUS) {
        const currentPos = window.camera.position.clone();
        const direction = currentPos.normalize();
        window.camera.position.copy(direction.multiplyScalar(window.BLACK_HOLE_RADIUS * 2.5));
        if (window.controls) {
            window.controls.update();
        }
    }
}

// Function to update distance explanation dynamically
function updateDistanceExplanation(rsDistance) {
    const explanationDiv = document.getElementById('distanceExplanation');
    let explanation = '';
    
    if (rsDistance >= 100) {
        explanation = 'Far from the black hole - Reality operates normally with minimal compression. Classical physics dominates.';
    } else if (rsDistance >= 50) {
        explanation = 'Distant orbit - Minor relativistic effects begin. Time flows 2% slower. Information compression barely noticeable.';
    } else if (rsDistance >= 20) {
        explanation = 'Approaching the black hole - Spacetime curvature becomes evident. Reality compression at 5%.';
    } else if (rsDistance >= 10) {
        explanation = 'Near field - Strong gravitational effects. Time slows by 10%. Compression artifacts emerge in particle behavior.';
    } else if (rsDistance >= 5) {
        explanation = 'Close approach - Heavy spacetime distortion. Reality compression at 20%. Quantum effects begin to surface.';
    } else if (rsDistance >= 3) {
        explanation = 'Photon sphere vicinity - Light can orbit here. Critical compression threshold. Information severely degraded.';
    } else if (rsDistance >= 2) {
        explanation = 'Extreme proximity - Half of reality information lost. Causality breaking down. Time at 41% speed.';
    } else if (rsDistance >= 1.5) {
        explanation = 'Near the point of no return - 67% compression loss. Spacetime foam dominates. Extreme quantum noise.';
    } else if (rsDistance >= 1.1) {
        explanation = 'Just above event horizon - 91% information lost. Time nearly frozen. Holographic limit approached.';
    } else {
        explanation = 'AT THE EVENT HORIZON - Complete information compression. 3D reality collapses to 2D. Time stops.';
    }
    
    explanationDiv.textContent = explanation;
}

// Add event listeners to interactive elements
['particleIndicator', 'timeIndicator', 'gravityIndicator', 'spaceIndicator'].forEach(id => {
    const element = document.getElementById(id);
    const data = interactiveData[id];
    
    element.addEventListener('mouseenter', () => showTooltip(element, data));
    element.addEventListener('mouseleave', hideTooltip);
    element.addEventListener('click', () => {
        hideTooltip();
        showModal({ ...data, id });
    });
});

// Add click handler for distance indicator
const distanceIndicator = document.getElementById('distanceIndicator');
if (distanceIndicator) {
    distanceIndicator.addEventListener('click', () => {
        const data = interactiveData.distanceIndicator;
        showModal({ ...data, id: 'distanceIndicator' });
    });
    
    // Add hover tooltip for distance indicator
    distanceIndicator.addEventListener('mouseenter', (e) => {
        const rect = distanceIndicator.getBoundingClientRect();
        tooltip.innerHTML = `<h4>Schwarzschild Radius</h4>Click to explore what Rs means and why distance matters`;
        tooltip.style.left = `${rect.left + rect.width / 2 - 125}px`;
        tooltip.style.top = `${rect.bottom + 10}px`;
        tooltip.classList.add('show');
    });
    
    distanceIndicator.addEventListener('mouseleave', () => {
        tooltip.classList.remove('show');
    });
}

// Close modal when clicking outside
document.getElementById('modal').addEventListener('click', (e) => {
    if (e.target.id === 'modal') {
        closeModal();
    }
});

// Hide info text after a delay
setTimeout(() => {
    const info = document.getElementById('info');
    if (info) {
        info.style.opacity = '0';
        info.style.transition = 'opacity 2s ease-out';
    }
}, 8000);

// Initialize distance explanation
updateDistanceExplanation(10.0);
</script>

</body>
</html>