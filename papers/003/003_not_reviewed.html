<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Compression Hypothesis: A Computational Framework for Testing Gravitational Theories</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    
    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
                        'mono': ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        'physics-blue': '#1a0dab',
                        'physics-light-blue': '#4285f4',
                        'physics-dark': '#202124',
                        'physics-gray': '#5f6368',
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Custom Aeonik Font */
        @font-face {
            font-family: 'Aeonik';
            src: url('https://cdn.jsdelivr.net/gh/juliusgarbe/aeonik-fonts@main/Aeonik-Regular.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
        }
        @font-face {
            font-family: 'Aeonik';
            src: url('https://cdn.jsdelivr.net/gh/juliusgarbe/aeonik-fonts@main/Aeonik-Medium.woff2') format('woff2');
            font-weight: 500;
            font-style: normal;
        }
        @font-face {
            font-family: 'Aeonik';
            src: url('https://cdn.jsdelivr.net/gh/juliusgarbe/aeonik-fonts@main/Aeonik-Bold.woff2') format('woff2');
            font-weight: 700;
            font-style: normal;
        }
        
        /* Use Aeonik for headings */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Aeonik', 'Inter', sans-serif;
        }
        
        /* Smooth scroll */
        html {
            scroll-behavior: smooth;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Math variables styling */
        .math-var {
            font-family: 'Times New Roman', 'Georgia', serif;
            font-style: italic;
            color: #1a0dab;
            font-size: 1.05em;
        }
        
        /* Formula display */
        .formula-display {
            @apply text-center text-physics-blue bg-blue-50 py-6 px-8 rounded-xl my-6 mx-auto;
            font-family: 'Times New Roman', 'Georgia', serif;
            font-size: 1.4rem;
            width: fit-content;
            min-width: 300px;
            box-shadow: 0 2px 8px rgba(26, 13, 171, 0.08);
            border: 1px solid #e0e7ff;
            position: relative;
        }
        
        .formula-display:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #1a0dab, #4285f4);
            border-radius: 12px 12px 0 0;
        }
        
        /* Story blockquote */
        .story-blockquote {
            @apply border-l-4 border-physics-light-blue pl-6 my-8 text-lg italic text-gray-700;
            font-family: 'Aeonik', 'Inter', sans-serif;
            line-height: 1.8;
        }
        
        /* Responsive canvas */
        @media (max-width: 768px) {
            canvas {
                max-width: 100% !important;
                height: auto !important;
            }
            
            .formula-display {
                font-size: 1.1rem;
                padding: 1.5rem 1rem;
                min-width: auto;
                width: 100%;
            }
        }
        
        /* Iframe container styling */
        .iframe-container {
            position: relative;
            width: 100%;
            padding-bottom: 75%; /* 4:3 aspect ratio for better visualization */
            height: 0;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            min-height: 700px;
        }
        
        .iframe-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            min-height: 700px;
        }
        
        @media (max-width: 768px) {
            .iframe-container {
                padding-bottom: 100%; /* Square on mobile */
                min-height: 500px;
            }
            .iframe-container iframe {
                min-height: 500px;
            }
        }
        
        /* Table improvements */
        .responsive-table {
            @apply w-full overflow-x-auto;
        }
        
        .responsive-table table {
            @apply min-w-full;
        }
        
        /* Mobile-first approach for tables */
        @media (max-width: 640px) {
            .responsive-table table {
                @apply text-sm;
            }
            
            .responsive-table th,
            .responsive-table td {
                @apply px-2 py-1;
            }
        }
        
        /* Animation classes */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        /* Collapsible table styling */
        .collapsible-table .collapsible-row {
            display: none;
        }
        .collapsible-table.expanded .collapsible-row {
            display: table-row;
        }
        
        /* Lightbox removed - images open in new tabs */
        
        /* Print styles */
        @media print {
            .no-print {
                display: none !important;
            }
            
            body {
                font-size: 12pt;
            }
            
            h1 { font-size: 24pt; }
            h2 { font-size: 20pt; }
            h3 { font-size: 16pt; }
        }
    </style>
</head>
<body class="bg-white text-physics-dark antialiased">

    <!-- Mobile Navigation -->
    <nav class="lg:hidden fixed top-0 left-0 right-0 bg-white shadow-md z-40 no-print">
        <div class="flex items-center justify-between px-4 py-3">
            <h2 class="text-lg font-semibold text-physics-blue">Compression Hypothesis</h2>
            <button id="mobile-menu-toggle" class="p-2 rounded-md hover:bg-gray-100">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
            </button>
        </div>
    </nav>
    
    <!-- Mobile Menu -->
    <div id="mobile-menu" class="lg:hidden fixed inset-0 bg-white z-50 transform translate-x-full transition-transform duration-300 no-print">
        <div class="p-4">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-semibold">Navigation</h3>
                <button id="mobile-menu-close" class="p-2 rounded-md hover:bg-gray-100">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <nav class="space-y-2">
                <a href="#abstract" class="block py-2 px-4 rounded hover:bg-gray-100">Abstract</a>
                <a href="#introduction" class="block py-2 px-4 rounded hover:bg-gray-100">1. Introduction</a>
                <a href="#methodology" class="block py-2 px-4 rounded hover:bg-gray-100">2. Methodology</a>
                <a href="#promising-candidates" class="block py-2 px-4 rounded hover:bg-gray-100">3. Promising Candidates</a>
                <a href="#gravity-robust" class="block py-2 px-4 rounded hover:bg-gray-100">4. Gravity as Robust Compression</a>
                <a href="#fourier-loss" class="block py-2 px-4 rounded hover:bg-gray-100">5. Scaling Steps</a>
                <a href="#ai-discovery" class="block py-2 px-4 rounded hover:bg-gray-100">6. AI-Assisted Discovery</a>
                <a href="#interactive-viz" class="block py-2 px-4 rounded hover:bg-gray-100">7. Interactive Visualization</a>
                <a href="#black-hole-visualization" class="block py-2 px-4 rounded hover:bg-gray-100">8. Black Hole Demo</a>
                <a href="#appendix-e" class="block py-2 px-4 rounded hover:bg-gray-100">9. Contributing</a>
                <a href="#experimental-validation" class="block py-2 px-4 rounded hover:bg-gray-100">10. Experimental Validation</a>
            </nav>
        </div>
    </div>
    
    <!-- Desktop Navigation -->
    <nav class="hidden lg:block fixed left-0 top-0 h-full w-64 bg-gray-50 border-r border-gray-200 overflow-y-auto no-print">
        <div class="p-6">
            <h3 class="text-lg font-semibold text-physics-blue mb-4">Navigation</h3>
            <nav class="space-y-1">
                <a href="#abstract" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">Abstract</a>
                <a href="#introduction" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">1. Introduction</a>
                <a href="#methodology" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">2. Methodology</a>
                <a href="#promising-candidates" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">3. Promising Candidates</a>
                <a href="#gravity-robust" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">4. Gravity as Robust Compression</a>
                <a href="#fourier-loss" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">5. Scaling Steps</a>
                <a href="#ai-discovery" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">6. AI-Assisted Discovery</a>
                <a href="#interactive-viz" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">7. Interactive Visualization</a>
                <a href="#black-hole-visualization" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">8. Black Hole Demo</a>
                <a href="#appendix-e" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">9. Contributing</a>
                <a href="#experimental-validation" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">10. Experimental Validation</a>
            </nav>
        </div>
    </nav>

    <!-- Lightbox removed - images now open in new tabs -->

    <!-- Main Content -->
    <div class="lg:ml-64 pt-16 lg:pt-0">
        <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-8 lg:py-12">

            <!-- Header -->
            <header class="mb-12 lg:mb-16 fade-in">
                <h1 class="text-3xl sm:text-4xl lg:text-5xl xl:text-6xl font-bold tracking-tight mb-4 lg:mb-6 text-physics-blue leading-tight">
                    Feedback Draft: The Compression Hypothesis
                </h1>
                <p class="text-lg lg:text-xl text-physics-gray leading-relaxed max-w-4xl">
                    A Computational Framework for Generating and Testing Gravitational Theories
                </p>
                <div class="mt-6 space-y-1 text-physics-gray">
                    <p class="font-medium">W.W.A. (Pim) de Witte, General Intuition PBC</p>
                    <p>pim@generalintuition.ai</p>
                    <p class="text-sm mt-2">July 10, 2025</p>
                </div>
            </header>

            <!-- Abstract -->
            <div id="abstract" class="bg-blue-50 border-l-4 border-physics-blue p-6 lg:p-8 rounded-r-lg mb-12 fade-in scroll-mt-20">
                <h2 class="text-2xl lg:text-3xl font-bold text-physics-blue mb-4">Abstract</h2>
                <div class="space-y-4 text-base lg:text-lg leading-relaxed">
                    <p>
                        Foundational principles such as the holographic principle and black hole thermodynamics suggest that gravity may be an emergent phenomenon rooted in information. 
                    </p>
                    <p>
                        To explore this hypothesis, we developed a computational framework treating gravitational theories as compression codecs and measuring their "decoding loss"—information destroyed when reconstructing particle trajectories. Using PyTorch, we systematically evaluated established gravitational theories alongside novel formulations generated through AI-assisted exploration of mathematical structures suggested by Einstein's final investigations. Our framework identified the "Linear Signal Loss" model as showing balanced losses against gravitational and electromagnetic baselines, suggesting potential unification signals. However, this is a computational proxy; future work must validate against real observations and develop full analytic derivations.
                    </p>
                </div>
            </div>

            <!-- Main Content Continues -->
            <main class="space-y-12 lg:space-y-16">
                <section class="section scroll-mt-20" id="introduction">
                    
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                        <div class="space-y-6">
                            <p class="text-base lg:text-lg leading-relaxed">
                                Modern physics grapples with a profound dichotomy: the universe's vast, high-dimensional quantum reality versus the smooth, low-dimensional classical spacetime in which we observe it. Principles like the holographic principle and black hole thermodynamics strongly suggest this is not a coincidence, but a deep feature of nature. A black hole, for instance, collapses the immense complexity of a star into just three numbers—mass, charge, and spin—with its information content encoded on its two-dimensional event horizon. This is a supreme act of information compression.
                            </p>
                            <p class="text-base lg:text-lg leading-relaxed">
                                This paper posits that gravity is not just the curvature of spacetime, but is rather the <strong class="bg-yellow-100 px-1 rounded">emergent thermodynamic and computational process that governs this compression</strong>. We propose that physical laws are algorithms that map the immense information of the quantum state (the input) onto a compressed, stable, latent representation (the classical world). In this view, the Einstein Field Equations are the "decoder"—the mathematical rules that allow for the reconstruction of the smooth spacetime geometry from the compressed information.
                            </p>
                            <p class="text-base lg:text-lg leading-relaxed">
                                If this hypothesis is correct, then physical theories can be evaluated not just on their predictive accuracy, but on their fidelity as decoding algorithms. A superior theory should minimize "loss," better reconstructing the observed dynamics from compressed information. This motivated our methodology: a framework to measure "decoding loss" by simulating orbital mechanics and quantifying deviations from ground truth geodesics.
                            </p>
                            <p class="text-base lg:text-lg leading-relaxed">
                                We acknowledge limitations: our framework operates within GR modifications and uses RN as an EM proxy. True unification requires deriving EM from geometry without ad-hoc fields. Our approach screens candidates computationally, with real validation planned.
                            </p>
                        </div>
                        
                        <div class="lg:sticky lg:top-8">
                            <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                <canvas id="compressionHypothesisCanvas" class="w-full" width="420" height="420"></canvas>
                                <p class="text-sm text-center text-physics-gray mt-4">The Compression Hypothesis: Physical laws as information codecs. Click to animate.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Canvas script remains the same -->
                    <script>
                        (function() {
                            const canvas = document.getElementById('compressionHypothesisCanvas');
                            const ctx = canvas.getContext('2d');
                            let animationFrame = 0;
                            let isPaused = false;
                            let compressionProgress = 0;
                            let waveOffset = 0;
                            
                            canvas.addEventListener('click', () => {
                                isPaused = !isPaused;
                                if (!isPaused) animate();
                            });
                            
                            // Add roundRect polyfill
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                            function drawQuantumState(x, y, size) {
                                // Draw complex quantum wavefunction
                                ctx.save();
                                ctx.translate(x, y);
                                
                                // Background circle
                                ctx.fillStyle = '#e8eaf6';
                                ctx.beginPath();
                                ctx.arc(0, 0, size, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Quantum waves
                                ctx.strokeStyle = '#3f51b5';
                                ctx.lineWidth = 1.5;
                                for (let i = 0; i < 5; i++) {
                                    ctx.beginPath();
                                    for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                                        const r = size * 0.5 + 10 * Math.sin(angle * 3 + waveOffset + i);
                                        const x = r * Math.cos(angle);
                                        const y = r * Math.sin(angle);
                                        if (angle === 0) ctx.moveTo(x, y);
                                        else ctx.lineTo(x, y);
                                    }
                                    ctx.closePath();
                                    ctx.globalAlpha = 0.3 - i * 0.05;
                                    ctx.stroke();
                                }
                                ctx.globalAlpha = 1;
                                
                                // Label
                                ctx.fillStyle = '#1a0dab';
                                ctx.font = 'bold 15px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Quantum State', 0, size + 25);
                                ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                ctx.fillStyle = '#5f6368';
                                ctx.fillText('(High-dimensional)', 0, size + 40);
                                
                                ctx.restore();
                            }
                            
                            function drawClassicalSpacetime(x, y, size) {
                                ctx.save();
                                ctx.translate(x, y);
                                
                                // Draw grid representing spacetime
                                ctx.strokeStyle = '#757575';
                                ctx.lineWidth = 1;
                                const gridSize = 15;
                                const halfSize = size;
                                
                                // Grid lines
                                for (let i = -halfSize; i <= halfSize; i += gridSize) {
                                    // Curved grid to show spacetime curvature
                                    ctx.beginPath();
                                    for (let j = -halfSize; j <= halfSize; j += 5) {
                                        const curvature = 20 * Math.exp(-((i*i + j*j) / (halfSize*halfSize)));
                                        if (j === -halfSize) ctx.moveTo(j, i - curvature);
                                        else ctx.lineTo(j, i - curvature);
                                    }
                                    ctx.stroke();
                                    
                                    ctx.beginPath();
                                    for (let j = -halfSize; j <= halfSize; j += 5) {
                                        const curvature = 20 * Math.exp(-((i*i + j*j) / (halfSize*halfSize)));
                                        if (j === -halfSize) ctx.moveTo(i, j - curvature);
                                        else ctx.lineTo(i, j - curvature);
                                    }
                                    ctx.stroke();
                                }
                                
                                // Central mass
                                const gradient = ctx.createRadialGradient(0, -10, 0, 0, -10, 30);
                                gradient.addColorStop(0, '#37474f');
                                gradient.addColorStop(1, '#90a4ae');
                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.arc(0, -10, 15, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Label
                                ctx.fillStyle = '#1a0dab';
                                ctx.font = 'bold 15px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Classical Spacetime', 0, size + 25);
                                ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                ctx.fillStyle = '#5f6368';
                                ctx.fillText('(4D Observable)', 0, size + 40);
                                
                                ctx.restore();
                            }
                            
                            function drawCompressionArrow(x1, y1, x2, y2, progress) {
                                const dx = x2 - x1;
                                const dy = y2 - y1;
                                const angle = Math.atan2(dy, dx);
                                
                                // Draw wavy arrow representing compression
                                ctx.save();
                                ctx.strokeStyle = '#4caf50';
                                ctx.lineWidth = 3;
                                ctx.setLineDash([5, 5]);
                                ctx.lineDashOffset = -animationFrame * 0.5;
                                
                                ctx.beginPath();
                                for (let t = 0; t <= progress; t += 0.02) {
                                    const x = x1 + dx * t;
                                    const y = y1 + dy * t + 10 * Math.sin(t * 10 + waveOffset);
                                    if (t === 0) ctx.moveTo(x, y);
                                    else ctx.lineTo(x, y);
                                }
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // Arrowhead
                                if (progress > 0.9) {
                                    const endX = x1 + dx * progress;
                                    const endY = y1 + dy * progress;
                                    ctx.translate(endX, endY);
                                    ctx.rotate(angle);
                                    ctx.fillStyle = '#4caf50';
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);
                                    ctx.lineTo(-15, -8);
                                    ctx.lineTo(-15, 8);
                                    ctx.closePath();
                                    ctx.fill();
                                }
                                ctx.restore();
                                
                                // Label
                                const midX = x1 + dx * 0.5;
                                const midY = y1 + dy * 0.5 - 20;
                                ctx.fillStyle = '#2e7d32';
                                ctx.font = 'bold 13px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('GRAVITY', midX, midY);
                                ctx.font = '11px Aeonik, -apple-system, sans-serif';
                                ctx.fillText('(Compression)', midX, midY + 12);
                            }
                            
                            function drawTheoryBox(x, y) {
                                // Draw theory evaluation box
                                ctx.fillStyle = '#fff3e0';
                                ctx.strokeStyle = '#f57c00';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.roundRect(x - 60, y - 25, 120, 50, 5);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.fillStyle = '#e65100';
                                ctx.font = 'bold 13px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Theory g_μν', x, y);
                                ctx.font = '11px Aeonik, -apple-system, sans-serif';
                                ctx.fillText('Decoder', x, y + 12);
                            }
                            
                            function drawLossIndicator(x, y, loss) {
                                // Draw loss meter
                                const width = 100;
                                const height = 20;
                                
                                ctx.fillStyle = '#f5f5f5';
                                ctx.strokeStyle = '#9e9e9e';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.roundRect(x - width/2, y - height/2, width, height, 3);
                                ctx.fill();
                                ctx.stroke();
                                
                                // Fill based on loss
                                const fillWidth = width * (1 - loss);
                                const color = loss < 0.1 ? '#4caf50' : loss < 0.5 ? '#ff9800' : '#f44336';
                                ctx.fillStyle = color;
                                ctx.beginPath();
                                ctx.roundRect(x - width/2, y - height/2, fillWidth, height, 3);
                                ctx.fill();
                                
                                // Label
                                ctx.fillStyle = '#202124';
                                ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Decoding Loss', x, y + 25);
                            }
                            
                            function animate() {
                                if (isPaused) return;
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                // Title
                                ctx.fillStyle = '#1a0dab';
                                ctx.font = 'bold 18px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('The Compression Hypothesis', canvas.width / 2, 30);
                                
                                // Update animation states
                                waveOffset += 0.05;
                                compressionProgress = (Math.sin(animationFrame * 0.02) + 1) * 0.5;
                                
                                // Draw components
                                drawQuantumState(100, 100, 50);
                                drawClassicalSpacetime(280, 100, 50);
                                drawCompressionArrow(150, 100, 230, 100, compressionProgress);
                                
                                // Draw theory evaluation
                                drawTheoryBox(190, 220);
                                
                                // Draw loss indicator
                                const loss = 0.1 + 0.4 * (1 - compressionProgress);
                                drawLossIndicator(190, 280, loss);
                                
                                // Information text
                                ctx.fillStyle = '#5f6368';
                                ctx.font = '11px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Physical laws = Information codecs', canvas.width / 2, 365);
                                ctx.fillText('Better theory = Lower decoding loss', canvas.width / 2, 380);
                                
                                animationFrame++;
                                requestAnimationFrame(animate);
                            }
                            
                            // Start animation
                            animate();
                        })();
                    </script>
                </section>

                <section class="section scroll-mt-20" id="methodology">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        2. Methodology: A Computational Framework for Testing Gravitational Theories
                    </h2>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                        <div class="space-y-6">
                            <p class="text-base lg:text-lg leading-relaxed">
                                Our methodology treats gravitational theories as information compression algorithms—each theory acts as a codec that encodes quantum states into classical spacetime and must decode them to recover observable dynamics. We formalize this by representing theories as metric tensor functions <span class="math-var">g<sub>μν</sub>(r, θ, φ, t; α<sub>i</sub>)</span> and evaluating their compression fidelity against ground truth geodesics.
                            </p>
                            <p class="text-base lg:text-lg leading-relaxed">
                                Our computational engine is built entirely in <strong>PyTorch</strong>, leveraging its deep learning foundations to implement and test gravitational theories as compression algorithms. This approach not only enables efficient tensor computations and automatic differentiation, but also makes the entire simulation pipeline accessible and reproducible.
                            </p>
                            <p class="text-base lg:text-lg leading-relaxed">
                                <strong>Anyone can set up and replicate our results or commit theories</strong> by running the open-source PyTorch simulation available at
                                <a href="https://github.com/PimDeWitte/gravity-compression" class="text-physics-blue underline break-all" target="_blank" rel="noopener">github.com/PimDeWitte/gravity-compression</a>.
                            </p>
                        </div>
                        
                        <div class="lg:sticky lg:top-8">
                            <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                <canvas id="computationalFrameworkCanvas" class="w-full" width="420" height="500"></canvas>
                                <p class="text-sm text-center text-physics-gray mt-4">Computational pipeline for testing gravitational theories. Click to see data flow.</p>
                            </div>
                        </div>
                    </div>
                    
                    <script>
                        (function() {
                            const canvas = document.getElementById('computationalFrameworkCanvas');
                            const ctx = canvas.getContext('2d');
                            let animationFrame = 0;
                            let isPaused = false;
                            let dataFlowProgress = 0;
                            let currentStage = 0;
                            
                            // Pipeline stages
                            const stages = [
                                { name: 'Gravitational Theory', y: 30, color: '#1a73e8', icon: 'g_μν' },
                                { name: 'Metric Tensor', y: 80, color: '#2196f3', icon: 'M' },
                                { name: 'Christoffel Symbols', y: 130, color: '#03a9f4', icon: 'Γ' },
                                { name: 'Geodesic Integration', y: 180, color: '#00bcd4', icon: '∫' },
                                { name: 'Trajectory r(t)', y: 230, color: '#009688', icon: 'r(t)' },
                                { name: 'Fourier Transform', y: 280, color: '#4caf50', icon: 'FFT' },
                                { name: 'Dual Baseline', y: 330, color: '#ff9800', icon: '⟷' },
                                { name: 'Loss Computation', y: 380, color: '#f44336', icon: 'L' }
                            ];
                            
                            // Validation tiers
                            const tiers = [
                                { name: 'TEST\n1K steps', x: 50, color: '#fdd835' },
                                { name: 'VALIDATION\n100K steps', x: 190, color: '#ff9800' },
                                { name: 'FINAL\n5M steps', x: 330, color: '#f44336' }
                            ];
                            
                            canvas.addEventListener('click', () => {
                                isPaused = !isPaused;
                                if (!isPaused) animate();
                            });
                            
                            function drawStage(stage, index) {
                                const x = canvas.width / 2;
                                const isActive = Math.floor(dataFlowProgress) === index;
                                const isPast = dataFlowProgress > index;
                                
                                // Draw box
                                ctx.fillStyle = isActive ? stage.color : (isPast ? stage.color + '40' : '#f8f9fa');
                                ctx.strokeStyle = stage.color;
                                ctx.lineWidth = isActive ? 3 : 1;
                                
                                const boxWidth = 200;
                                const boxHeight = 35;
                                
                                ctx.beginPath();
                                ctx.roundRect(x - boxWidth/2, stage.y - boxHeight/2, boxWidth, boxHeight, 5);
                                ctx.fill();
                                ctx.stroke();
                                
                                // Draw icon
                                ctx.fillStyle = isActive ? '#ffffff' : stage.color;
                                ctx.font = 'bold 15px Georgia, serif';
                                ctx.textAlign = 'center';
                                ctx.fillText(stage.icon, x - boxWidth/2 + 30, stage.y + 4);
                                
                                // Draw label
                                ctx.fillStyle = isActive ? '#ffffff' : '#202124';
                                ctx.font = '13px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText(stage.name, x + 20, stage.y + 3);
                                
                                // Draw arrow to next stage
                                if (index < stages.length - 1) {
                                    const nextStage = stages[index + 1];
                                    const arrowProgress = Math.max(0, Math.min(1, dataFlowProgress - index));
                                    
                                    if (arrowProgress > 0) {
                                        const startY = stage.y + boxHeight/2;
                                        const endY = nextStage.y - boxHeight/2;
                                        const currentY = startY + (endY - startY) * arrowProgress;
                                        
                                        ctx.strokeStyle = stage.color;
                                        ctx.lineWidth = 2;
                                        ctx.beginPath();
                                        ctx.moveTo(x, startY);
                                        ctx.lineTo(x, currentY);
                                        ctx.stroke();
                                        
                                        // Arrowhead
                                        if (arrowProgress > 0.8) {
                                            ctx.fillStyle = stage.color;
                                            ctx.beginPath();
                                            ctx.moveTo(x, currentY);
                                            ctx.lineTo(x - 5, currentY - 8);
                                            ctx.lineTo(x + 5, currentY - 8);
                                            ctx.closePath();
                                            ctx.fill();
                                        }
                                    }
                                }
                            }
                            
                            function drawDualBaseline() {
                                const baselineY = stages[6].y;
                                const x = canvas.width / 2;
                                const isActive = Math.floor(dataFlowProgress) === 6;
                                
                                if (dataFlowProgress >= 6) {
                                    // Draw baseline boxes
                                    const baselineWidth = 85;
                                    const spacing = 65;
                                    
                                    // Schwarzschild baseline
                                    ctx.fillStyle = isActive ? '#e3f2fd' : '#f8f9fa';
                                    ctx.strokeStyle = '#1976d2';
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.roundRect(x - spacing - baselineWidth, baselineY - 15, baselineWidth, 30, 3);
                                    ctx.fill();
                                    ctx.stroke();
                                    ctx.fillStyle = '#1976d2';
                                    ctx.font = '11px Aeonik, -apple-system, sans-serif';
                                    ctx.textAlign = 'center';
                                    ctx.fillText('Schwarzschild', x - spacing - baselineWidth/2, baselineY + 3);
                                    
                                    // Reissner-Nordström baseline
                                    ctx.fillStyle = isActive ? '#fff3e0' : '#f8f9fa';
                                    ctx.strokeStyle = '#f57c00';
                                    ctx.beginPath();
                                    ctx.roundRect(x + spacing, baselineY - 15, baselineWidth, 30, 3);
                                    ctx.fill();
                                    ctx.stroke();
                                    ctx.fillStyle = '#f57c00';
                                    ctx.fillText('Reissner-N', x + spacing + baselineWidth/2, baselineY + 3);
                                }
                            }
                            
                            function drawValidationTiers() {
                                const tierY = 415;
                                
                                ctx.fillStyle = '#5f6368';
                                ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Validation Tiers:', canvas.width / 2, tierY);
                                
                                tiers.forEach(tier => {
                                    const isActive = dataFlowProgress >= stages.length - 1;
                                    
                                    ctx.fillStyle = isActive ? tier.color + '20' : '#f8f9fa';
                                    ctx.strokeStyle = tier.color;
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.roundRect(tier.x - 30, tierY + 8, 60, 32, 3);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    ctx.fillStyle = tier.color;
                                    ctx.font = '10px Aeonik, -apple-system, sans-serif';
                                    const lines = tier.name.split('\n');
                                    lines.forEach((line, i) => {
                                        ctx.fillText(line, tier.x, tierY + 20 + i * 11);
                                    });
                                });
                            }
                            
                            function animate() {
                                if (isPaused) return;
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                // Draw stages
                                stages.forEach((stage, index) => {
                                    drawStage(stage, index);
                                });
                                
                                // Draw dual baseline comparison
                                drawDualBaseline();
                                
                                // Draw validation tiers at bottom
                                drawValidationTiers();
                                
                                // Update data flow
                                dataFlowProgress += 0.02;
                                if (dataFlowProgress > stages.length) {
                                    dataFlowProgress = 0;
                                }
                                
                                animationFrame++;
                                requestAnimationFrame(animate);
                            }
                            
                            // Add roundRect polyfill for older browsers
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                            // Start animation
                            animate();
                        })();
                    </script>
                    
                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">2.2 Dual-Baseline Methodology</h3>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                        <div class="space-y-6">
                            <p class="text-base lg:text-lg leading-relaxed">
                                A key innovation in our approach is the use of two complementary baselines for theory evaluation:
                            </p>
                            <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                                <h4 class="font-semibold text-physics-blue mb-4">Baseline 1: Schwarzschild Metric (Pure Gravity)</h4>
                                <div class="formula-display">
                                    ds² = -(1 - r<sub>s</sub>/r)dt² + (1 - r<sub>s</sub>/r)<sup>-1</sup>dr² + r²dΩ²
                                </div>
                                <p class="text-sm lg:text-base">Represents the exact solution for a non-rotating, uncharged mass. Used to evaluate a theory's fidelity to pure gravitational dynamics.</p>
                            </div>
                            <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                                <h4 class="font-semibold text-physics-blue mb-4">Baseline 2: Reissner-Nordström Metric (Gravity + Electromagnetism)</h4>
                                <div class="formula-display">
                                    ds² = -(1 - r<sub>s</sub>/r + r<sub>q</sub>²/r²)dt² + (1 - r<sub>s</sub>/r + r<sub>q</sub>²/r²)<sup>-1</sup>dr² + r²dΩ²
                                </div>
                                <p class="text-sm lg:text-base">Represents the exact solution for a charged mass. Used to evaluate a theory's ability to unify gravitational and electromagnetic phenomena.</p>
                            </div>
                            <p class="text-base lg:text-lg leading-relaxed">
                                This dual-baseline approach enables us to assess whether a candidate theory correctly reproduces pure gravitational dynamics while also capturing electromagnetic effects when present, providing insight into potential unified field theories.
                            </p>
                        </div>
                        
                        <div class="lg:sticky lg:top-8">
                            <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                <canvas id="dualBaselineCanvas" class="w-full" width="420" height="500"></canvas>
                                <p class="text-sm text-center text-physics-gray mt-4">Dual-baseline evaluation: Each theory is tested against both gravitational and electromagnetic ground truths. Click to animate.</p>
                            </div>
                        </div>
                    </div>
                    
                    <script>
                        (function() {
                            const canvas = document.getElementById('dualBaselineCanvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Set up canvas dimensions
                            canvas.width = 420;
                            canvas.height = 500;
                            
                            // Animation state
                            let animationPhase = 0;
                            let phaseProgress = 0;
                            let isPaused = false;
                            
                            // Add roundRect polyfill for older browsers
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                                        // Pause/play on click
            canvas.addEventListener('click', () => {
                isPaused = !isPaused;
                if (!isPaused) animate();
            });
            
            function drawNeutralMass(x, y) {
                // Draw central mass
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 12);
                gradient.addColorStop(0, '#37474f');
                gradient.addColorStop(1, '#90a4ae');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw orbit ellipse
                ctx.strokeStyle = '#1976d2';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 2]);
                ctx.beginPath();
                ctx.ellipse(x, y, 25, 15, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw test particle
                const angle = animationPhase * 0.03;
                const particleX = x + 25 * Math.cos(angle);
                const particleY = y + 15 * Math.sin(angle);
                ctx.fillStyle = '#1976d2';
                ctx.beginPath();
                ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            function drawChargedMass(x, y) {
                // Draw central charged mass
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, 12);
                gradient.addColorStop(0, '#ff6f00');
                gradient.addColorStop(1, '#ffa726');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw charge field lines
                ctx.strokeStyle = '#ff9800';
                ctx.lineWidth = 0.5;
                ctx.globalAlpha = 0.5;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(x + 12 * Math.cos(angle), y + 12 * Math.sin(angle));
                    ctx.lineTo(x + 30 * Math.cos(angle), y + 30 * Math.sin(angle));
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
                
                // Draw plus sign for charge
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x - 5, y);
                ctx.lineTo(x + 5, y);
                ctx.moveTo(x, y - 5);
                ctx.lineTo(x, y + 5);
                ctx.stroke();
                
                // Draw orbit ellipse
                ctx.strokeStyle = '#f57c00';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 2]);
                ctx.beginPath();
                ctx.ellipse(x, y, 25, 15, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw test particle (affected by both gravity and EM)
                const angle = animationPhase * 0.03;
                const particleX = x + 25 * Math.cos(angle);
                const particleY = y + 15 * Math.sin(angle);
                ctx.fillStyle = '#f57c00';
                ctx.beginPath();
                ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            function drawScene() {
                                // Clear canvas
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                // Title - always visible
                                ctx.fillStyle = '#1a0dab';
                                ctx.font = 'bold 22px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('How We Test Theories', canvas.width / 2, 35);
                                
                                // Phase 1: Show the theory being tested
                                if (animationPhase >= 0) {
                                    const opacity = animationPhase === 0 ? phaseProgress : 1;
                                    ctx.globalAlpha = opacity;
                                    
                                    // Theory box
                                    ctx.fillStyle = '#e8eaf6';
                                    ctx.strokeStyle = '#3f51b5';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.roundRect(110, 70, 200, 60, 10);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    ctx.fillStyle = '#1a0dab';
                                    ctx.font = 'bold 18px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('New Theory', 210, 95);
                                    ctx.font = '14px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('(Our best guess)', 210, 115);
                                    
                                    ctx.globalAlpha = 1;
                                }
                                
                                // Phase 2: Show Test 1 - Gravity Only
                                if (animationPhase >= 1) {
                                    const opacity = animationPhase === 1 ? phaseProgress : 1;
                                    ctx.globalAlpha = opacity;
                                    
                                    // Arrow to Test 1
                                    ctx.strokeStyle = '#616161';
                                    ctx.lineWidth = 2;
                                    ctx.setLineDash([5, 3]);
                                    ctx.beginPath();
                                    ctx.moveTo(160, 130);
                                    ctx.lineTo(120, 180);
                                    ctx.stroke();
                                    ctx.setLineDash([]);
                                    
                                    // Test 1 box
                                    ctx.fillStyle = '#e3f2fd';
                                    ctx.strokeStyle = '#1976d2';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.roundRect(40, 180, 160, 100, 10);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    // Draw neutral mass with orbit
                                    drawNeutralMass(120, 210);
                                    
                                    ctx.fillStyle = '#1976d2';
                                    ctx.font = 'bold 14px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('Schwarzschild', 120, 240);
                                    ctx.fillStyle = '#202124';
                                    ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('Orbits around a', 120, 255);
                                    ctx.fillText('neutral mass', 120, 268);
                                    
                                    ctx.globalAlpha = 1;
                                }
                                
                                // Phase 3: Show Test 2 - Gravity + Electricity
                                if (animationPhase >= 2) {
                                    const opacity = animationPhase === 2 ? phaseProgress : 1;
                                    ctx.globalAlpha = opacity;
                                    
                                    // Arrow to Test 2
                                    ctx.strokeStyle = '#616161';
                                    ctx.lineWidth = 2;
                                    ctx.setLineDash([5, 3]);
                                    ctx.beginPath();
                                    ctx.moveTo(260, 130);
                                    ctx.lineTo(300, 180);
                                    ctx.stroke();
                                    ctx.setLineDash([]);
                                    
                                    // Test 2 box
                                    ctx.fillStyle = '#fff3e0';
                                    ctx.strokeStyle = '#f57c00';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.roundRect(220, 180, 160, 100, 10);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    // Draw charged mass with orbit
                                    drawChargedMass(300, 210);
                                    
                                    ctx.fillStyle = '#f57c00';
                                    ctx.font = 'bold 14px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('Reissner-Nordström', 300, 240);
                                    ctx.fillStyle = '#202124';
                                    ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('Orbits around a', 300, 255);
                                    ctx.fillText('charged mass', 300, 268);
                                    
                                    ctx.globalAlpha = 1;
                                }
                                
                                // Phase 4: Show scores
                                if (animationPhase >= 3) {
                                    const opacity = animationPhase === 3 ? phaseProgress : 1;
                                    ctx.globalAlpha = opacity;
                                    
                                    // Score for Test 1
                                    ctx.fillStyle = '#ffffff';
                                    ctx.strokeStyle = '#1976d2';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.roundRect(70, 300, 100, 50, 8);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    ctx.fillStyle = '#1976d2';
                                    ctx.font = 'bold 14px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('Score:', 120, 320);
                                    ctx.font = 'bold 20px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('85%', 120, 340);
                                    
                                    // Score for Test 2
                                    ctx.fillStyle = '#ffffff';
                                    ctx.strokeStyle = '#f57c00';
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.roundRect(250, 300, 100, 50, 8);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    ctx.fillStyle = '#f57c00';
                                    ctx.font = 'bold 14px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('Score:', 300, 320);
                                    ctx.font = 'bold 20px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('84%', 300, 340);
                                    
                                    ctx.globalAlpha = 1;
                                }
                                
                                // Phase 5: Show verdict
                                if (animationPhase >= 4) {
                                    const opacity = animationPhase === 4 ? phaseProgress : 1;
                                    ctx.globalAlpha = opacity;
                                    
                                    // Verdict box
                                    ctx.fillStyle = '#e8f5e9';
                                    ctx.strokeStyle = '#4caf50';
                                    ctx.lineWidth = 3;
                                    ctx.beginPath();
                                    ctx.roundRect(60, 380, 300, 80, 10);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    // Checkmark
                                    ctx.font = '30px Arial';
                                    ctx.fillText('✅', 190, 415);
                                    
                                    ctx.fillStyle = '#2e7d32';
                                    ctx.font = 'bold 18px Aeonik, -apple-system, sans-serif';
        
                                    ctx.fillStyle = '#616161';
                                    ctx.font = '14px Aeonik, -apple-system, sans-serif';
                                    ctx.fillText('Similar losses = unified field behavior', 210, 445);
                                    
                                    ctx.globalAlpha = 1;
                                }
                                
                                // Instructions
                                ctx.fillStyle = '#5f6368';
                                ctx.font = 'italic 12px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText(isPaused ? 'Click to continue' : 'Click to pause', canvas.width / 2, 485);
                            }
                            
                            function animate() {
                                if (isPaused) return;
                                
                                drawScene();
                                
                                // Update animation progress
                                phaseProgress += 0.03;
                                
                                if (phaseProgress >= 1) {
                                    phaseProgress = 0;
                                    animationPhase++;
                                    
                                    // Loop back to beginning
                                    if (animationPhase > 4) {
                                        animationPhase = 0;
                                        // Pause for a moment at the end
                                        setTimeout(() => {
                                            if (!isPaused) requestAnimationFrame(animate);
                                        }, 2000);
                                        return;
                                    }
                                }
                                
                                requestAnimationFrame(animate);
                            }
                            
                            // Start animation
                            animate();
                        })();
                    </script>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">2.3 Geodesic Integration Method</h3>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        The core computational task is solving the geodesic equation for test particles in each candidate metric:
                    </p>
                    <div class="formula-display">
                        d²x<sup>μ</sup>/dλ² + Γ<sup>μ</sup><sub>νρ</sub> (dx<sup>ν</sup>/dλ)(dx<sup>ρ</sup>/dλ) = 0
                    </div>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        Where Γ<sup>μ</sup><sub>νρ</sub> are the Christoffel symbols computed from the metric tensor. We employ a fourth-order Runge-Kutta integrator with adaptive time stepping to maintain numerical stability near the event horizon. The integration parameters are:
                    </p>
                    <ul class="list-disc list-inside space-y-2 text-base lg:text-lg">
                        <li><strong>Initial Radius:</strong> r<sub>0</sub> = 10 r<sub>s</sub> (10 Schwarzschild radii)</li>
                        <li><strong>Time Step:</strong> Δτ = T<sub>orbit</sub>/1000, where T<sub>orbit</sub> is the Keplerian orbital period</li>
                        <li><strong>Precision:</strong> Configurable between float32 (rapid screening) and float64 (high-precision validation)</li>
                    </ul>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">2.4 Loss Metric Design</h3>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        We employ two complementary loss metrics to quantify theoretical performance:
                    </p>
                    <h4 class="text-lg font-semibold text-physics-dark mt-8 mb-4">2.4.1 Trajectory Distance Loss</h4>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        The primary metric measures the mean squared deviation between the candidate theory's predicted trajectory and the ground truth:
                    </p>
                    <div class="formula-display">
                        L<sub>traj</sub> = (1/N) Σ<sub>i=1</sub><sup>N</sup> ||r<sub>i</sub><sup>candidate</sup> - r<sub>i</sub><sup>truth</sup>||²
                    </div>
                    <p class="text-base lg:text-lg leading-relaxed">
                        This provides a direct measure of positional accuracy over the entire orbital evolution.
                    </p>
                    
                    <h4 class="text-lg font-semibold text-physics-dark mt-8 mb-4">2.4.2 Fourier Transform Loss</h4>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        For enhanced sensitivity to orbital dynamics, we compute the loss in frequency space:
                    </p>
                    <div class="formula-display">
                        L<sub>FFT</sub> = ||FFT(r<sup>candidate</sup>(t)) - FFT(r<sup>truth</sup>(t))||²
                    </div>
                    <p class="text-base lg:text-lg leading-relaxed">
                        This metric is particularly sensitive to differences in orbital precession rates and periodic effects, allowing detection of subtle deviations that might be masked in position space.
                    </p>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">2.5 Three-Tier Validation System</h3>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        To balance computational efficiency with scientific rigor, we implement a three-tier validation hierarchy:
                    </p>
                    <div class="responsive-table">
                        <table class="w-full border-collapse">
                            <thead>
                                <tr class="bg-gray-50">
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Mode</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Steps</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Purpose</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Computational Time</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">TEST</td>
                                    <td class="px-4 py-3 border-b">1,000</td>
                                    <td class="px-4 py-3 border-b">Rapid screening for stability and gross errors</td>
                                    <td class="px-4 py-3 border-b">~0.001s (GPU)</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">VALIDATION</td>
                                    <td class="px-4 py-3 border-b">100,000</td>
                                    <td class="px-4 py-3 border-b">High-fidelity testing with FFT analysis</td>
                                    <td class="px-4 py-3 border-b">~0.1s (GPU)</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">FINAL</td>
                                    <td class="px-4 py-3 border-b">5,000,000</td>
                                    <td class="px-4 py-3 border-b">Publication-quality verification of breakthroughs</td>
                                    <td class="px-4 py-3 border-b">~5s (GPU)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <p class="text-base lg:text-lg leading-relaxed mt-4">
                        This tiered approach enables testing of hundreds of candidate theories per hour in TEST mode while reserving computational resources for thorough validation of promising candidates.
                    </p>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                        
               
                  
                </section>

                <section class="section scroll-mt-20" id="promising-candidates">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        3. Promising Test Candidates (1000 Steps)
                    </h2>
                    <p class="text-base lg:text-lg leading-relaxed mb-8">
                        Beyond the main performance ranking, our dual-baseline methodology revealed a select group of theories that demonstrate exceptional promise for unifying gravity and electromagnetism. These candidates maintain low loss values against both baselines, indicating potential unified structures.
                    </p>

                    <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                        <!-- Linear Signal Loss (γ=+0.75) -->
                        <div class="bg-white border border-gray-200 rounded-xl shadow-sm hover:shadow-lg transition-shadow duration-300 overflow-hidden">
                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 border-b border-gray-200">
                                <h3 class="text-lg font-semibold text-physics-blue">5.1 Linear Signal Loss (γ=+0.75)</h3>
                            </div>
                            <div class="flex gap-2 p-4 bg-gray-50 justify-center">
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+0_75/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+0_75/plot.png" 
                                         alt="Trajectory" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+0_75/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+0_75/metric_plot.png" 
                                         alt="Metric" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                            <div class="p-4 space-y-3">
                                <p class="text-sm font-medium text-physics-blue">
                                    Performance: Loss_GR: 0.153, Loss_RN: 0.161
                                </p>
                                <div class="bg-blue-50 p-3 rounded-lg">
                                    <p class="text-sm font-mono text-center">
                                        <span class="math-var">m = (1 - γ (r_s / r)) × (1 - r_s / r)</span>
                                    </p>
                                </div>
                                <p class="text-sm text-physics-gray italic">
                                    Balanced losses suggest unification through information degradation.
                                </p>
                            </div>
                        </div>

                        <!-- Linear Signal Loss (γ=+1.00) -->
                        <div class="bg-white border border-gray-200 rounded-xl shadow-sm hover:shadow-lg transition-shadow duration-300 overflow-hidden">
                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 border-b border-gray-200">
                                <h3 class="text-lg font-semibold text-physics-blue">5.2 Linear Signal Loss (γ=+1.00)</h3>
                            </div>
                            <div class="flex gap-2 p-4 bg-gray-50 justify-center">
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+1_00/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+1_00/plot.png" 
                                         alt="Trajectory" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+1_00/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+1_00/metric_plot.png" 
                                         alt="Metric" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                            <div class="p-4 space-y-3">
                                <p class="text-sm font-medium text-physics-blue">
                                    Performance: Loss_GR: 0.133, Loss_RN: 0.133
                                </p>
                                <div class="bg-blue-50 p-3 rounded-lg">
                                    <p class="text-sm font-mono text-center">
                                        <span class="math-var">m = (1 - γ (r_s / r)) × (1 - r_s / r)</span>
                                    </p>
                                </div>
                                <p class="text-sm text-physics-gray italic">
                                    Perfect balance at full degradation indicates robust unification.
                                </p>
                            </div>
                        </div>

                        <!-- Participatory (w=0.92) -->
                        <div class="bg-white border border-gray-200 rounded-xl shadow-sm hover:shadow-lg transition-shadow duration-300 overflow-hidden">
                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 border-b border-gray-200">
                                <h3 class="text-lg font-semibold text-physics-blue">5.3 Participatory (w=0.92)</h3>
                            </div>
                            <div class="flex gap-2 p-4 bg-gray-50 justify-center">
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193614_Participatory_w_0_92/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193614_Participatory_w_0_92/plot.png" 
                                         alt="Trajectory" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193614_Participatory_w_0_92/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193614_Participatory_w_0_92/metric_plot.png" 
                                         alt="Metric" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                            <div class="p-4 space-y-3">
                                <p class="text-sm font-medium text-physics-blue">
                                    Performance: Loss_GR: 0.030, Loss_RN: 0.184
                                </p>
                                <div class="bg-blue-50 p-3 rounded-lg">
                                    <p class="text-sm font-mono text-center">
                                        <span class="math-var">m = w × (1 - r_s / r) + (1 - w) × 1</span>
                                    </p>
                                </div>
                                <p class="text-sm text-physics-gray italic">
                                    Strong gravitational performance with moderate unification potential.
                                </p>
                            </div>
                        </div>

                        <!-- Variable G (δ=-0.10) -->
                        <div class="bg-white border border-gray-200 rounded-xl shadow-sm hover:shadow-lg transition-shadow duration-300 overflow-hidden">
                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 border-b border-gray-200">
                                <h3 class="text-lg font-semibold text-physics-blue">5.4 Variable G (δ=-0.10)</h3>
                            </div>
                            <div class="flex gap-2 p-4 bg-gray-50 justify-center">
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_194520_Variable_G_δ_-0_10/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_194520_Variable_G_δ_-0_10/plot.png" 
                                         alt="Trajectory" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_194520_Variable_G_δ_-0_10/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_194520_Variable_G_δ_-0_10/metric_plot.png" 
                                         alt="Metric" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                            <div class="p-4 space-y-3">
                                <p class="text-sm font-medium text-physics-blue">
                                    Performance: Loss_GR: 0.197, Loss_RN: 0.083
                                </p>
                                <div class="bg-blue-50 p-3 rounded-lg">
                                    <p class="text-sm font-mono text-center">
                                        <span class="math-var">G_{eff} = G × (1 + δ log(1 + r / r_s))</span>
                                    </p>
                                </div>
                                <p class="text-sm text-physics-gray italic">
                                    Better RN performance suggests variable G aids unification.
                                </p>
                            </div>
                        </div>

                        <!-- Log Corrected (β=+0.17) -->
                        <div class="bg-white border border-gray-200 rounded-xl shadow-sm hover:shadow-lg transition-shadow duration-300 overflow-hidden">
                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 border-b border-gray-200">
                                <h3 class="text-lg font-semibold text-physics-blue">5.5 Log Corrected (β=+0.17)</h3>
                            </div>
                            <div class="flex gap-2 p-4 bg-gray-50 justify-center">
                                <a href="../../runs/20250710_193244/quantum_predefined/promising/20250710_203421_Log_Corrected_β_+0_17/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/quantum_predefined/promising/20250710_203421_Log_Corrected_β_+0_17/plot.png" 
                                         alt="Trajectory" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250710_193244/quantum_predefined/promising/20250710_203421_Log_Corrected_β_+0_17/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/quantum_predefined/promising/20250710_203421_Log_Corrected_β_+0_17/metric_plot.png" 
                                         alt="Metric" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                            <div class="p-4 space-y-3">
                                <p class="text-sm font-medium text-physics-blue">
                                    Performance: Loss_GR: 0.625, Loss_RN: 0.012
                                </p>
                                <div class="bg-blue-50 p-3 rounded-lg">
                                    <p class="text-sm font-mono text-center">
                                        <span class="math-var">m = 1 - r_s / r + β (r_s / r) log(r / r_s)</span>
                                    </p>
                                </div>
                                <p class="text-sm text-physics-gray italic">
                                    Strong RN performance indicates logarithmic quantum corrections.
                                </p>
                            </div>
                        </div>

                        <!-- Quantum Corrected (α=+2.00) -->
                        <div class="bg-white border border-gray-200 rounded-xl shadow-sm hover:shadow-lg transition-shadow duration-300 overflow-hidden">
                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 border-b border-gray-200">
                                <h3 class="text-lg font-semibold text-physics-blue">5.6 Quantum Corrected (α=+2.00)</h3>
                            </div>
                            <div class="flex gap-2 p-4 bg-gray-50 justify-center">
                                <a href="../../runs/20250710_193244/quantum_predefined/promising/20250710_204852_Quantum_Corrected_α_+2_00/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/quantum_predefined/promising/20250710_204852_Quantum_Corrected_α_+2_00/plot.png" 
                                         alt="Trajectory" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250710_193244/quantum_predefined/promising/20250710_204852_Quantum_Corrected_α_+2_00/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/quantum_predefined/promising/20250710_204852_Quantum_Corrected_α_+2_00/metric_plot.png" 
                                         alt="Metric" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                            <div class="p-4 space-y-3">
                                <p class="text-sm font-medium text-physics-blue">
                                    Performance: Loss_GR: 0.010, Loss_RN: 0.218
                                </p>
                                <div class="bg-blue-50 p-3 rounded-lg">
                                    <p class="text-sm font-mono text-center">
                                        <span class="math-var">m = 1 - r_s / r + α (r_s / r)³</span>
                                    </p>
                                </div>
                                <p class="text-sm text-physics-gray italic">
                                    Cubic correction maintains good gravitational fidelity.
                                </p>
                            </div>
                        </div>
                    </div>

                </section>

                <section class="section scroll-mt-20" id="gravity-robust">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        4. Linear Signal Loss 
                    </h2>
                    
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        We draw inspiration from Joint Embedding Predictive Architectures (JEPAs) in machine learning, which excel at learning robust representations by predicting missing or noisy information in latent space. Applying this concept to physics, we designed a new theoretical model to explicitly test the resilience of the gravitational "algorithm":
                    </p>
                    <ul class="list-disc list-inside space-y-3 text-base lg:text-lg mb-8">
                        <li><strong>Linear Signal Loss:</strong> Introduces a parameter degrading the gravitational "signal" near the central mass. This measures the theory's "breaking point"—information loss before predictions diverge from stable GR orbits. Analogous to image degradation in lossy compression.</li>
                    </ul>
                    
                    <div class="mt-12 mb-12">

                        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
                            <div class="lg:col-span-7">
                                <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                    <canvas id="linearSignalLossDeepDiveCanvas" class="w-full" width="650" height="850"></canvas>
                                    <p class="text-sm text-center text-physics-gray mt-4">
                                        Interactive deep dive into Linear Signal Loss unification. Click on any step to see detailed mathematical derivations. Use buttons to explore different γ values.
                                    </p>
                                </div>
                            </div>
                            
                            <div class="lg:col-span-5">
                                <div id="linearSignalLossDetails" class="bg-blue-50 border-l-4 border-physics-blue p-6 rounded-r-lg min-h-[400px] mb-4">
                                    <h5 class="text-lg font-semibold text-physics-blue mb-4">Mathematical Details</h5>
                                    <p id="lslDetailContent" class="text-sm lg:text-base leading-relaxed">
                                        Click on any step in the diagram to see detailed mathematical explanations and physical interpretations.
                                    </p>
                                </div>
                                
                                <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg">
                                    <h5 class="text-lg font-semibold text-green-700 mb-4">Key Insight</h5>
                                    <p class="text-sm lg:text-base leading-relaxed">
                                        Linear Signal Loss achieves unification by demonstrating that gravity and electromagnetism are not separate forces, but different aspects of the same information compression process. When the gravitational signal degrades, both phenomena degrade proportionally—evidence they share a common information-theoretic substrate.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <script>
                        (function() {
                            const canvas = document.getElementById('linearSignalLossDeepDiveCanvas');
                            const ctx = canvas.getContext('2d');
                            const detailDiv = document.getElementById('lslDetailContent');
                            
                            let currentGamma = 0.75;
                            let hoveredStep = -1;
                            let animationFrame = 0;
                            let selectedStep = -1;
                            
                            // Define the steps of the unification process
                            const steps = [
                                {
                                    title: "Step 1: Standard GR Metric",
                                    y: 80,
                                    formula: "g_tt = -(1 - r_s/r)",
                                    description: "Starting with the Schwarzschild metric of General Relativity. This represents pure gravitational information encoded in spacetime curvature.",
                                    details: `The Schwarzschild metric describes spacetime around a spherical mass M:
                                    
ds² = -(1 - r_s/r)dt² + (1 - r_s/r)⁻¹dr² + r²dΩ²

Where r_s = 2GM/c² is the Schwarzschild radius. This metric encodes all gravitational information as the deviation from flat spacetime (where g_tt = -1). The term (1 - r_s/r) represents the "gravitational signal" - the information content of the gravitational field.`
                                },
                                {
                                    title: "Step 2: Signal Extraction",
                                    y: 180,
                                    formula: "Signal = (1 - r_s/r)",
                                    description: "The gravitational 'signal' is the deviation from flat spacetime. This represents the information content that must be preserved.",
                                    details: `The gravitational signal S(r) = (1 - r_s/r) can be interpreted as:

• S → 1: Far from the mass (weak gravity, nearly flat)
• S → 0: At the event horizon (maximum curvature)
• S < 0: Inside the event horizon (unphysical region)

This signal carries ALL information about the gravitational field. In the compression hypothesis, this is the data that must be encoded and transmitted without loss for GR to be "lossless".`
                                },
                                {
                                    title: "Step 3: Information Degradation",
                                    y: 280,
                                    formula: "Degraded Signal = (1 - γ·r_s/r)",
                                    description: "Introduce parameter γ to systematically degrade the signal. This simulates information loss in the compression channel.",
                                    details: `The degradation parameter γ ∈ [0,1] acts as an information filter:

• γ = 0: No degradation (perfect transmission)
• γ = 0.5: 50% signal loss
• γ = 0.75: 75% signal loss (our test case)
• γ = 1: Complete loss (flat spacetime)

This is analogous to lossy compression in information theory. We're asking: "What happens to physics when the universe can only transmit (1-γ) fraction of the gravitational information?"`
                                },
                                {
                                    title: "Step 4: Metric Reconstruction",
                                    y: 380,
                                    formula: "g_tt = -(1 - γr_s/r)(1 - r_s/r)",
                                    description: "The Linear Signal Loss metric multiplies the degraded signal with the original structure, creating a non-linear interaction.",
                                    details: `The full Linear Signal Loss metric is:

g_tt = -(1 - γr_s/r)(1 - r_s/r)
     = -(1 - r_s/r - γr_s/r + γ(r_s/r)²)
     = -(1 - (1+γ)r_s/r + γ(r_s/r)²)

This creates a complex interplay:
• Linear term: -(1+γ)r_s/r (enhanced gravity)
• Quadratic term: +γ(r_s/r)² (opposing effect)

The non-linearity is crucial - it means information loss doesn't simply weaken gravity uniformly, but changes its fundamental structure.`
                                },
                                {
                                    title: "Step 5: Dual-Channel Testing",
                                    y: 480,
                                    formula: "Loss_GR ≈ Loss_RN",
                                    description: "When tested against both baselines, the losses are nearly equal (0.153 vs 0.161), revealing unified behavior.",
                                    details: `The remarkable result: γ=0.75 yields:
                                    
• Loss vs Schwarzschild (pure gravity): 0.153
• Loss vs Reissner-Nordström (gravity+EM): 0.161

The near-equality (ratio ≈ 0.95) is profound. It means:

1. Information degradation affects both channels equally
2. Gravity and EM share the same compression substrate
3. They're not separate forces but different projections of the same unified information field

This wouldn't happen if gravity and EM were truly independent - we'd expect wildly different loss ratios.`
                                },
                                {
                                    title: "Step 6: Unification Principle",
                                    y: 580,
                                    formula: "Unified Field = Info[Gravity] ∪ Info[EM]",
                                    description: "Both forces emerge from the same information-theoretic substrate. Degrading the substrate affects both equally.",
                                    details: `The Linear Signal Loss model reveals the unification principle:

TRADITIONAL VIEW:
• Gravity = Curved spacetime (Einstein)
• EM = Gauge field on spacetime (Maxwell)
• Unification = Find common geometry

COMPRESSION VIEW:
• Reality = Information compression algorithm
• Gravity = Compression of mass/energy info
• EM = Compression of charge info
• Both use the SAME compression infrastructure

When we degrade the compression quality (γ), both channels degrade proportionally because they're using the same underlying codec. This is why Linear Signal Loss achieves unification - not by adding fields, but by revealing the common information-theoretic foundation.`
                                }
                            ];
                            
                            // Interactive regions
                            const buttons = [
                                { x: 20, y: 720, width: 100, height: 35, gamma: 0.25, label: "γ = 0.25" },
                                { x: 130, y: 720, width: 100, height: 35, gamma: 0.50, label: "γ = 0.50" },
                                { x: 240, y: 720, width: 100, height: 35, gamma: 0.75, label: "γ = 0.75" },
                                { x: 350, y: 720, width: 100, height: 35, gamma: 0.90, label: "γ = 0.90" },
                                { x: 460, y: 720, width: 100, height: 35, gamma: 1.00, label: "γ = 1.00" }
                            ];
                            
                            // Add roundRect polyfill
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                            function drawStep(step, index, isHovered, isSelected) {
                                const x = 30;
                                const width = 540;
                                const height = 70;
                                
                                // Draw connection to next step
                                if (index < steps.length - 1) {
                                    const nextStep = steps[index + 1];
                                    const gradient = ctx.createLinearGradient(x + width/2, step.y + height, x + width/2, nextStep.y);
                                    gradient.addColorStop(0, '#4caf50');
                                    gradient.addColorStop(1, '#2196f3');
                                    
                                    ctx.strokeStyle = gradient;
                                    ctx.lineWidth = 3;
                                    ctx.setLineDash([5, 5]);
                                    ctx.lineDashOffset = -animationFrame * 0.5;
                                    ctx.beginPath();
                                    ctx.moveTo(x + width/2, step.y + height);
                                    ctx.lineTo(x + width/2, nextStep.y);
                                    ctx.stroke();
                                    ctx.setLineDash([]);
                                }
                                
                                // Draw step box
                                ctx.fillStyle = isSelected ? '#e3f2fd' : (isHovered ? '#f3e5f5' : '#ffffff');
                                ctx.strokeStyle = isSelected ? '#1976d2' : (isHovered ? '#9c27b0' : '#dadce0');
                                ctx.lineWidth = isSelected ? 3 : (isHovered ? 2 : 1);
                                
                                ctx.beginPath();
                                ctx.roundRect(x, step.y, width, height, 5);
                                ctx.fill();
                                ctx.stroke();
                                
                                // Draw step number
                                ctx.fillStyle = '#1a0dab';
                                ctx.font = 'bold 15px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'left';
                                ctx.fillText(step.title, x + 15, step.y + 25);
                                
                                // Draw formula
                                ctx.fillStyle = '#202124';
                                ctx.font = 'italic 17px Georgia, serif';
                                ctx.textAlign = 'center';
                                ctx.fillText(step.formula, x + width/2, step.y + 50);
                                
                                // Draw click hint
                                if (isHovered && !isSelected) {
                                    ctx.fillStyle = '#5f6368';
                                    ctx.font = '11px Aeonik, -apple-system, sans-serif';
                                    ctx.textAlign = 'right';
                                    ctx.fillText('Click for details →', x + width - 15, step.y + 60);
                                }
                            }
                            
                            function drawVisualization() {
                                // Draw signal degradation visualization
                                const vizX = 100;
                                const vizY = 670;
                                const vizWidth = 400;
                                const vizHeight = 30;
                                
                                // Background
                                ctx.fillStyle = '#f8f9fa';
                                ctx.fillRect(vizX, vizY, vizWidth, vizHeight);
                                ctx.strokeStyle = '#dadce0';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(vizX, vizY, vizWidth, vizHeight);
                                
                                // Signal strength gradient
                                const gradient = ctx.createLinearGradient(vizX, vizY, vizX + vizWidth, vizY);
                                gradient.addColorStop(0, '#4caf50');
                                gradient.addColorStop(0.5, '#ff9800');
                                gradient.addColorStop(1, '#f44336');
                                
                                ctx.fillStyle = gradient;
                                ctx.fillRect(vizX, vizY, vizWidth * (1 - currentGamma), vizHeight);
                                
                                // Labels
                                ctx.fillStyle = '#202124';
                                ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Signal Strength: ' + ((1 - currentGamma) * 100).toFixed(0) + '%', vizX + vizWidth/2, vizY - 5);
                                
                                // Gamma indicator
                                const indicatorX = vizX + vizWidth * (1 - currentGamma);
                                ctx.strokeStyle = '#202124';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(indicatorX, vizY - 5);
                                ctx.lineTo(indicatorX, vizY + vizHeight + 5);
                                ctx.stroke();
                            }
                            
                            function drawButtons() {
                                buttons.forEach(button => {
                                    const isActive = Math.abs(button.gamma - currentGamma) < 0.01;
                                    
                                    ctx.fillStyle = isActive ? '#1a0dab' : '#ffffff';
                                    ctx.strokeStyle = isActive ? '#1a0dab' : '#dadce0';
                                    ctx.lineWidth = isActive ? 2 : 1;
                                    
                                    ctx.beginPath();
                                    ctx.roundRect(button.x, button.y, button.width, button.height, 3);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    ctx.fillStyle = isActive ? '#ffffff' : '#202124';
                                    ctx.font = '13px Aeonik, -apple-system, sans-serif';
                                    ctx.textAlign = 'center';
                                    ctx.fillText(button.label, button.x + button.width/2, button.y + button.height/2 + 4);
                                });
                            }
                            
                            function draw() {
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                // Title
                                ctx.fillStyle = '#1a0dab';
                                ctx.font = 'bold 20px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Linear Signal Loss: Step-by-Step Unification', canvas.width/2, 35);
                                
                                // Draw all steps
                                steps.forEach((step, index) => {
                                    drawStep(step, index, hoveredStep === index, selectedStep === index);
                                });
                                
                                // Draw visualization
                                drawVisualization();
                                
                                // Draw buttons
                                drawButtons();
                                
                                // Draw current gamma value
                                ctx.fillStyle = '#202124';
                                ctx.font = '15px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Current γ = ' + currentGamma.toFixed(2), canvas.width/2, 770);
                                
                                animationFrame++;
                                requestAnimationFrame(draw);
                            }
                            
                            // Mouse interaction
                            canvas.addEventListener('mousemove', (e) => {
                                const rect = canvas.getBoundingClientRect();
                                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                                
                                hoveredStep = -1;
                                steps.forEach((step, index) => {
                                    if (x >= 30 && x <= 570 && y >= step.y && y <= step.y + 70) {
                                        hoveredStep = index;
                                        canvas.style.cursor = 'pointer';
                                        return;
                                    }
                                });
                                
                                if (hoveredStep === -1) {
                                    canvas.style.cursor = 'default';
                                }
                            });
                            
                            canvas.addEventListener('click', (e) => {
                                const rect = canvas.getBoundingClientRect();
                                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                                
                                // Check step clicks
                                steps.forEach((step, index) => {
                                    if (x >= 30 && x <= 570 && y >= step.y && y <= step.y + 70) {
                                        selectedStep = index;
                                        detailDiv.innerHTML = `<strong>${step.title}</strong><br><br>${step.details.replace(/\n/g, '<br>')}`;
                                        return;
                                    }
                                });
                                
                                // Check button clicks
                                buttons.forEach(button => {
                                    if (x >= button.x && x <= button.x + button.width &&
                                        y >= button.y && y <= button.y + button.height) {
                                        currentGamma = button.gamma;
                                        
                                        // Update detail text based on gamma
                                        let interpretation = '';
                                        if (currentGamma < 0.3) {
                                            interpretation = 'At low γ values, the system behaves nearly like standard GR. Both gravitational and electromagnetic channels remain strongly coupled.';
                                        } else if (currentGamma < 0.7) {
                                            interpretation = 'Moderate signal degradation begins to reveal the unified nature. The proportional loss in both channels becomes apparent.';
                                        } else if (currentGamma < 0.9) {
                                            interpretation = 'At γ=0.75, we see optimal unification behavior. The loss ratio GR:RN ≈ 0.95 demonstrates that both forces degrade together.';
                                        } else {
                                            interpretation = 'Near complete signal loss. The system approaches flat spacetime, losing all gravitational and electromagnetic information equally.';
                                        }
                                        
                                        if (selectedStep === -1) {
                                            detailDiv.innerHTML = `<strong>Signal Degradation: γ = ${currentGamma}</strong><br><br>${interpretation}`;
                                        }
                                    }
                                });
                            });
                            
                            // Start animation
                            draw();
                            
                            // Set initial detail text
                            detailDiv.innerHTML = `<strong>Welcome to the Linear Signal Loss Deep Dive</strong><br><br>
                            This interactive diagram shows how Linear Signal Loss achieves unification by revealing that gravity and electromagnetism share a common information-theoretic foundation.<br><br>
                            • Click on any step to see detailed mathematics<br>
                            • Use the γ buttons to explore different degradation levels<br>
                            • Watch how the signal strength visualization changes<br><br>
                            The key insight: When we degrade the gravitational signal, both gravity AND electromagnetism degrade proportionally - proving they emerge from the same underlying information compression process.`;
                        })();
                    </script>
                </section>

                <section class="section scroll-mt-20" id="fourier-loss">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        5. Scaling Steps
                    </h2>
                    
                    <p class="text-base lg:text-lg leading-relaxed mb-6">
                        Subsequent to the initial geodesic tests, the loss metric was refined to overcome the limitations of a simple final-state distance comparison. A more sophisticated method, employing a Fast Fourier Transform (FFT) Mean Squared Error (MSE), was implemented. This technique treats the time series of each coordinate of an orbit as a signal and compares the frequency spectra of the candidate theory against the ground truth. An orbit is not merely a path, but a composition of frequencies—a "symphony" of periodic motions. The FFT loss metric quantifies how closely the candidate's symphony matches that of General Relativity, providing an exceptionally sensitive measure of the entire orbital dynamics, including subtle effects like relativistic precession which manifest as distinct frequencies. This has resolved the earlier geometric degeneracy and provides a more physically robust ranking.
                    </p>

                    <p class="text-base lg:text-lg leading-relaxed">
                        For the history of experimentation before implementing the Fourier-based loss metric and using PyTorch, please refer to <a href="../../papers/002/002_not_reviewed.html" class="text-physics-blue hover:underline font-medium">the previous paper documenting the progress</a>.
                    </p>
                    <div class="mt-8">
                       
                    
                        <hr class="border-gray-300 my-12" />
    
                        <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg mb-6">
                            <h4 class="text-lg font-semibold text-green-700 mb-3">8.1 Linear Signal Loss (γ=+1.00)</h4>
                            <p class="mb-2"><strong>Final Loss vs Schwarzschild (GR):</strong> 0.133 | <strong>Final Loss vs Reissner-Nordström (RN):</strong> 0.133 | <strong>Loss Ratio (GR/RN):</strong> 1.000</p>
                            <div class="formula-display mb-4">
                                g_{tt} = -(1 - \gamma (r_s / r)) (1 - r_s / r)
                            </div>
                            <p class="text-sm lg:text-base mb-4">
                                Perfect symmetry in losses indicates complete unification at maximal signal degradation. The orbit maintains remarkable stability over 5M steps, with Fourier analysis showing identical frequency shifts in both baselines (maximum deviation <0.005% in primary orbital frequency). This suggests gravity and EM are dual manifestations of the same compression process.
                            </p>
                            <div class="flex gap-2 justify-center mb-4">
                                <a href="../../runs/20250711_012926/classical_predefined/promising/20250711_070238_Linear_Signal_Loss_γ_+1_00/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/promising/20250711_070238_Linear_Signal_Loss_γ_+1_00/plot.png" 
                                         alt="Trajectory for Linear Signal Loss (γ=+1.00)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250711_012926/classical_predefined/promising/20250711_070238_Linear_Signal_Loss_γ_+1_00/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/promising/20250711_070238_Linear_Signal_Loss_γ_+1_00/metric_plot.png" 
                                         alt="Metric for Linear Signal Loss (γ=+1.00)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                        </div>
    
                        <!-- Result 2: Linear Signal Loss (γ=+0.75) -->
                        <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg mb-6">
                            <h4 class="text-lg font-semibold text-green-700 mb-3">8.2 Linear Signal Loss (γ=+0.75)</h4>
                            <p class="mb-2"><strong>Final Loss vs Schwarzschild (GR):</strong> 0.153 | <strong>Final Loss vs Reissner-Nordström (RN):</strong> 0.161 | <strong>Loss Ratio (GR/RN):</strong> 0.950</p>
                            <div class="formula-display mb-4">
                                g_{tt} = -(1 - \gamma (r_s / r)) (1 - r_s / r)
                            </div>
                            <p class="text-sm lg:text-base mb-4">
                                Near-perfect balance (ratio 0.95) at 75% degradation. Trajectory shows minimal divergence over 5M steps, with Fourier spectra revealing matched precession rates in both baselines (deviation <0.01%). This configuration demonstrates robust unification while preserving physical stability.
                            </p>
                            <div class="flex gap-2 justify-center mb-4">
                                <a href="../../runs/20250711_012926/classical_predefined/promising/20250711_070232_Linear_Signal_Loss_γ_+0_75/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/promising/20250711_070232_Linear_Signal_Loss_γ_+0_75/plot.png" 
                                         alt="Trajectory for Linear Signal Loss (γ=+0.75)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250711_012926/classical_predefined/promising/20250711_070232_Linear_Signal_Loss_γ_+0_75/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/promising/20250711_070232_Linear_Signal_Loss_γ_+0_75/metric_plot.png" 
                                         alt="Metric for Linear Signal Loss (γ=+0.75)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                        </div>
    
                        <!-- Result 3: Linear Signal Loss (γ=+0.50) -->
                        <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg mb-6">
                            <h4 class="text-lg font-semibold text-green-700 mb-3">8.3 Linear Signal Loss (γ=+0.50)</h4>
                            <p class="mb-2"><strong>Final Loss vs Schwarzschild (GR):</strong> 0.179 | <strong>Final Loss vs Reissner-Nordström (RN):</strong> 0.192 | <strong>Loss Ratio (GR/RN):</strong> 0.932</p>
                            <div class="formula-display mb-4">
                                g_{tt} = -(1 - \gamma (r_s / r)) (1 - r_s / r)
                            </div>
                            <p class="text-sm lg:text-base mb-4">
                                Strong balance at 50% degradation, with losses remaining proportional. Simulation shows stable orbits with gradual divergence; Fourier analysis indicates preserved harmonic structure in both baselines (secondary frequency match >99%).
                            </p>
                            <div class="flex gap-2 justify-center mb-4">
                                <a href="../../runs/20250711_012926/classical_predefined/20250711_070236_Linear_Signal_Loss_γ_+0_50/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/20250711_070236_Linear_Signal_Loss_γ_+0_50/plot.png" 
                                         alt="Trajectory for Linear Signal Loss (γ=+0.50)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250711_012926/classical_predefined/20250711_070236_Linear_Signal_Loss_γ_+0_50/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/20250711_070236_Linear_Signal_Loss_γ_+0_50/metric_plot.png" 
                                         alt="Metric for Linear Signal Loss (γ=+0.50)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                        </div>
    
                        <!-- Result 4: Linear Signal Loss (γ=+0.25) -->
                        <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg mb-6">
                            <h4 class="text-lg font-semibold text-green-700 mb-3">8.4 Linear Signal Loss (γ=+0.25)</h4>
                            <p class="mb-2"><strong>Final Loss vs Schwarzschild (GR):</strong> 0.201 | <strong>Final Loss vs Reissner-Nordström (RN):</strong> 0.218 | <strong>Loss Ratio (GR/RN):</strong> 0.922</p>
                            <div class="formula-display mb-4">
                                g_{tt} = -(1 - \gamma (r_s / r)) (1 - r_s / r)
                            </div>
                            <p class="text-sm lg:text-base mb-4">
                                Maintained proportionality at lower degradation, approaching GR behavior while showing unified characteristics. 5M-step integration reveals minimal instability, with Fourier spectra closely matching baselines (primary frequency deviation <0.02%).
                            </p>
                            <div class="flex gap-2 justify-center mb-4">
                                <a href="../../runs/20250711_012926/classical_predefined/20250711_070238_Linear_Signal_Loss_γ_+0_25/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/20250711_070238_Linear_Signal_Loss_γ_+0_25/plot.png" 
                                         alt="Trajectory for Linear Signal Loss (γ=+0.25)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250711_012926/classical_predefined/20250711_070238_Linear_Signal_Loss_γ_+0_25/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/20250711_070238_Linear_Signal_Loss_γ_+0_25/metric_plot.png" 
                                         alt="Metric for Linear Signal Loss (γ=+0.25)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                        </div>
    
                        <!-- Result 5: Linear Signal Loss (γ=+0.00) -->
                        <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg mb-6">
                            <h4 class="text-lg font-semibold text-green-700 mb-3">8.5 Linear Signal Loss (γ=+0.00)</h4>
                            <p class="mb-2"><strong>Final Loss vs Schwarzschild (GR):</strong> 0.000 | <strong>Final Loss vs Reissner-Nordström (RN):</strong> 0.250 | <strong>Loss Ratio (GR/RN):</strong> 0.000</p>
                            <div class="formula-display mb-4">
                                g_{tt} = -(1 - \gamma (r_s / r)) (1 - r_s / r)
                            </div>
                            <p class="text-sm lg:text-base mb-4">
                                Zero degradation recovers exact GR (loss=0 vs Schwarzschild), validating the model. Higher RN loss shows baseline separation, but serves as the unification anchor point. Perfect stability over 5M steps with identical Fourier spectra to GR.
                            </p>
                            <div class="flex gap-2 justify-center mb-4">
                                <a href="../../runs/20250711_012926/classical_predefined/20250711_070237_Linear_Signal_Loss_γ_+0_00/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/20250711_070237_Linear_Signal_Loss_γ_+0_00/plot.png" 
                                         alt="Trajectory for Linear Signal Loss (γ=+0.00)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250711_012926/classical_predefined/20250711_070237_Linear_Signal_Loss_γ_+0_00/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250711_012926/classical_predefined/20250711_070237_Linear_Signal_Loss_γ_+0_00/metric_plot.png" 
                                         alt="Metric for Linear Signal Loss (γ=+0.00)" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                        </div>
    
                        <div class="mt-8 p-6 bg-gray-50 rounded-xl">
                            <h3 class="text-xl font-semibold text-physics-blue mb-4">Synthesis of Results</h3>
                            <p class="text-base lg:text-lg leading-relaxed">
                                The Linear Signal Loss family shows systematic proportionality in losses against both baselines as degradation increases. This provides a tunable framework for quantum gravity investigations, but requires further validation against observations.
                            </p>
                        </div>
                </section>

                <section class="section scroll-mt-20" id="ai-discovery">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        6. AI-Assisted Theory Discovery
                    </h2>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start mb-8">
                        <div class="space-y-6">
                            <p class="text-base lg:text-lg leading-relaxed">
                                What if we could give Einstein the computational power he lacked? What theories might he have discovered with access to modern AI and simulation capabilities? Our AI-assisted discovery system attempts to answer these questions by creating a bridge between Einstein's final mathematical insights and the vast computational resources of the 21st century.
                            </p>
                            <p class="text-base lg:text-lg leading-relaxed">
                                At his bedside in 1955, Einstein left behind pages of calculations—non-symmetric metrics, torsion fields, and mysterious coupling constants. These weren't random scribblings but systematic attempts to geometrically unify gravity and electromagnetism. Our discovery loop transforms these historical fragments into a living research program, using large language models as mathematical explorers to navigate the infinite space of possible unified field theories.
                            </p>
                            
                            <h4 class="text-lg font-semibold text-physics-blue mt-8 mb-4">5.1 From Manual Interpretation to Automated Discovery</h4>
                            <p class="text-base lg:text-lg leading-relaxed">
                                Before developing the fully automated discovery loop, our initial approach was a manual, interpretative process. We used large language models, including early versions of Grok and Gemini, as creative partners to explore the conceptual space of unified field theories. The primary goal was to interpret the notoriously cryptic notes left by Einstein on his deathbed, which hinted at solutions involving non-symmetric metrics and torsion.
                            </p>
                            <p class="text-base lg:text-lg leading-relaxed">
                                We would prompt these AIs with questions about these concepts, asking them to explain the mathematics and speculate on how they might be formulated into a concrete spacetime metric. This human-AI dialogue was insightful but slow; it required a physicist to translate the AI's textual, often qualitative, descriptions into valid, testable Python code. This effort produced a valuable set of "manual theories" that captured these initial interpretations, summarized below.
                            </p>
                            
                            <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg mb-6">
                                <p class="mb-0"><strong>📊 Deep Dive Available:</strong> For a comprehensive technical exploration of the AI discovery loop including system architecture, prompt evolution, and running instructions, see <a href="https://www.pimdewitte.com/gravity-compression/papers/003/ai_discovery_diagram.html" target="_blank" class="text-physics-blue hover:underline font-medium">The Discovery Loop →</a> or <a href="https://github.com/PimDeWitte/gravity-compression/tree/main/runs/20250711_004816/unified_predefined" target="_blank" class="text-physics-blue hover:underline font-medium">View the Formulas →</a></p>
                            </div>
                            
                            
                        </div>
                        
                        <div class="lg:sticky lg:top-8">
                            <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                <canvas id="aiDiscoveryVisualization" class="w-full" width="420" height="600"></canvas>
                                <p class="text-sm text-center text-physics-gray mt-4">The AI Discovery Bridge: From Einstein's deathbed notes to modern computational exploration. Click to animate the discovery process.</p>
                            </div>
                        </div>
                    </div>
                    
                    <script>
                        (function() {
                            const canvas = document.getElementById('aiDiscoveryVisualization');
                            const ctx = canvas.getContext('2d');
                            let animationFrame = 0;
                            let isPaused = false;
                            let particles = [];
                            let theoryNodes = [];
                            let connections = [];
                            let selectedTheory = null;
                            let discoveryPhase = 0;
                            
                            // Initialize particles for flow effect
                            for (let i = 0; i < 20; i++) {
                                particles.push({
                                    x: Math.random() * canvas.width,
                                    y: Math.random() * 200,
                                    vx: (Math.random() - 0.5) * 0.5,
                                    vy: Math.random() * 0.3 + 0.1,
                                    size: Math.random() * 2 + 1,
                                    opacity: Math.random() * 0.5 + 0.3
                                });
                            }
                            
                            // Theory exploration nodes
                            const theories = [
                                { name: "Non-symmetric g_μν", x: 100, y: 450, discovered: false, loss: null },
                                { name: "Torsion S^λ_μν", x: 200, y: 480, discovered: false, loss: null },
                                { name: "Kaluza-Klein 5D", x: 300, y: 450, discovered: false, loss: null },
                                { name: "Teleparallel", x: 150, y: 520, discovered: false, loss: null },
                                { name: "Linear Signal Loss", x: 250, y: 550, discovered: false, loss: null, breakthrough: true }
                            ];
                            
                            canvas.addEventListener('click', () => {
                                isPaused = !isPaused;
                                if (!isPaused) animate();
                            });
                            
                            // Add roundRect polyfill
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                            function drawEinsteinNotes() {
                                // Draw aged paper background
                                const gradient = ctx.createLinearGradient(20, 20, 380, 180);
                                gradient.addColorStop(0, '#fef9e7');
                                gradient.addColorStop(1, '#f4e7d1');
                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.roundRect(20, 20, 360, 160, 10);
                                ctx.fill();
                                ctx.strokeStyle = '#8b7355';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                
                                // Draw handwritten equations
                                ctx.font = 'italic 16px Georgia, serif';
                                ctx.fillStyle = '#2c3e50';
                                ctx.fillText('g_μν ≠ g_νμ', 50, 60);
                                ctx.fillText('S^λ_μν = Γ^λ_μν - Γ^λ_νμ', 50, 90);
                                ctx.fillText('α ≈ 1/137', 50, 120);
                                ctx.fillText('∂_μ(√-g g^μν) = ?', 50, 150);
                                
                                // Date stamp
                                ctx.font = '11px Aeonik, sans-serif';
                                ctx.fillStyle = '#7f8c8d';
                                ctx.fillText('April 1955', 280, 160);
                                
                                // Title
                                ctx.font = 'bold 14px Aeonik, sans-serif';
                                ctx.fillStyle = '#1a0dab';
                                ctx.textAlign = 'center';
                                ctx.fillText("Einstein's Final Notes", 200, 200);
                                ctx.textAlign = 'left';
                            }
                            
                            function drawAIProcessor() {
                                const centerY = 280;
                                
                                // Draw neural network visualization
                                ctx.strokeStyle = '#4285f4';
                                ctx.lineWidth = 1;
                                
                                // Input layer
                                for (let i = 0; i < 3; i++) {
                                    const y = centerY - 30 + i * 30;
                                    ctx.beginPath();
                                    ctx.arc(100, y, 5, 0, Math.PI * 2);
                                    ctx.fillStyle = '#e3f2fd';
                                    ctx.fill();
                                    ctx.stroke();
                                }
                                
                                // Hidden layers
                                for (let layer = 0; layer < 3; layer++) {
                                    const x = 150 + layer * 50;
                                    for (let i = 0; i < 4; i++) {
                                        const y = centerY - 45 + i * 30;
                                        
                                        // Draw connections
                                        ctx.strokeStyle = '#4285f4';
                                        ctx.globalAlpha = 0.3;
                                        ctx.lineWidth = 0.5;
                                        
                                        // Connect to previous layer
                                        if (layer > 0) {
                                            for (let j = 0; j < 4; j++) {
                                                ctx.beginPath();
                                                ctx.moveTo(x - 50, centerY - 45 + j * 30);
                                                ctx.lineTo(x, y);
                                                ctx.stroke();
                                            }
                                        } else {
                                            // Connect to input
                                            for (let j = 0; j < 3; j++) {
                                                ctx.beginPath();
                                                ctx.moveTo(100, centerY - 30 + j * 30);
                                                ctx.lineTo(x, y);
                                                ctx.stroke();
                                            }
                                        }
                                        
                                        ctx.globalAlpha = 1;
                                        
                                        // Draw node
                                        const activation = Math.sin(animationFrame * 0.02 + layer + i) * 0.5 + 0.5;
                                        ctx.beginPath();
                                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                                        ctx.fillStyle = `rgba(66, 133, 244, ${0.3 + activation * 0.7})`;
                                        ctx.fill();
                                        ctx.strokeStyle = '#4285f4';
                                        ctx.lineWidth = 1;
                                        ctx.stroke();
                                    }
                                }
                                
                                // Output layer
                                for (let i = 0; i < 3; i++) {
                                    const y = centerY - 30 + i * 30;
                                    
                                    // Connect to last hidden layer
                                    ctx.globalAlpha = 0.3;
                                    ctx.lineWidth = 0.5;
                                    for (let j = 0; j < 4; j++) {
                                        ctx.beginPath();
                                        ctx.moveTo(250, centerY - 45 + j * 30);
                                        ctx.lineTo(300, y);
                                        ctx.stroke();
                                    }
                                    ctx.globalAlpha = 1;
                                    
                                    ctx.beginPath();
                                    ctx.arc(300, y, 5, 0, Math.PI * 2);
                                    ctx.fillStyle = '#e3f2fd';
                                    ctx.fill();
                                    ctx.strokeStyle = '#4285f4';
                                    ctx.lineWidth = 1;
                                    ctx.stroke();
                                }
                                
                                // Label
                                ctx.font = 'bold 14px Aeonik, sans-serif';
                                ctx.fillStyle = '#1a0dab';
                                ctx.textAlign = 'center';
                                ctx.fillText('AI Theory Generator', 200, 350);
                                ctx.fillText('(Grok-4)', 200, 365);
                                ctx.textAlign = 'left';
                            }
                            
                            function drawTheorySpace() {
                                // Draw exploration space background
                                const gradient = ctx.createRadialGradient(210, 480, 50, 210, 480, 150);
                                gradient.addColorStop(0, 'rgba(232, 234, 246, 0.3)');
                                gradient.addColorStop(1, 'rgba(232, 234, 246, 0)');
                                ctx.fillStyle = gradient;
                                ctx.fillRect(0, 380, canvas.width, 220);
                                
                                // Draw theory nodes
                                theories.forEach((theory, index) => {
                                    const isActive = discoveryPhase > index * 20;
                                    
                                    if (isActive && !theory.discovered) {
                                        theory.discovered = true;
                                        theory.loss = theory.breakthrough ? 0.157 : (0.2 + Math.random() * 0.8);
                                    }
                                    
                                    // Draw connections between discovered theories
                                    if (theory.discovered && index > 0) {
                                        ctx.strokeStyle = 'rgba(66, 133, 244, 0.2)';
                                        ctx.lineWidth = 1;
                                        ctx.beginPath();
                                        ctx.moveTo(theories[index - 1].x, theories[index - 1].y);
                                        ctx.lineTo(theory.x, theory.y);
                                        ctx.stroke();
                                    }
                                    
                                    // Draw node
                                    ctx.beginPath();
                                    ctx.arc(theory.x, theory.y, theory.discovered ? 12 : 8, 0, Math.PI * 2);
                                    
                                    if (theory.discovered) {
                                        if (theory.breakthrough) {
                                            // Pulsing effect for breakthrough
                                            const pulse = Math.sin(animationFrame * 0.05) * 0.3 + 0.7;
                                            ctx.fillStyle = `rgba(76, 175, 80, ${pulse})`;
                                            ctx.strokeStyle = '#4caf50';
                                            ctx.lineWidth = 3;
                                        } else {
                                            const quality = 1 - theory.loss;
                                            const r = Math.floor(255 * theory.loss);
                                            const g = Math.floor(255 * quality);
                                            ctx.fillStyle = `rgba(${r}, ${g}, 80, 0.7)`;
                                            ctx.strokeStyle = `rgb(${r}, ${g}, 80)`;
                                            ctx.lineWidth = 2;
                                        }
                                    } else {
                                        ctx.fillStyle = 'rgba(189, 189, 189, 0.3)';
                                        ctx.strokeStyle = '#bdbdbd';
                                        ctx.lineWidth = 1;
                                    }
                                    
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    // Draw label
                                    if (theory.discovered) {
                                        ctx.font = '11px Aeonik, sans-serif';
                                        ctx.fillStyle = '#202124';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(theory.name, theory.x, theory.y + 25);
                                        
                                        // Draw loss value
                                        ctx.font = '10px monospace';
                                        ctx.fillStyle = theory.breakthrough ? '#4caf50' : '#5f6368';
                                        ctx.fillText(`Loss: ${theory.loss.toFixed(3)}`, theory.x, theory.y + 38);
                                    }
                                });
                                
                                // Title
                                ctx.font = 'bold 14px Aeonik, sans-serif';
                                ctx.fillStyle = '#1a0dab';
                                ctx.textAlign = 'center';
                                ctx.fillText('Theory Discovery Space', 200, 400);
                                ctx.textAlign = 'left';
                            }
                            
                            function drawFlowParticles() {
                                particles.forEach(particle => {
                                    // Update position
                                    particle.x += particle.vx;
                                    particle.y += particle.vy;
                                    
                                    // Reset if out of bounds
                                    if (particle.y > 380) {
                                        particle.y = 180;
                                        particle.x = 100 + Math.random() * 200;
                                    }
                                    
                                    // Draw particle
                                    ctx.beginPath();
                                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                                    ctx.fillStyle = `rgba(66, 133, 244, ${particle.opacity})`;
                                    ctx.fill();
                                });
                            }
                            
                            function drawStats() {
                                // Draw stats box
                                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                                ctx.strokeStyle = '#dadce0';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.roundRect(280, 420, 120, 80, 5);
                                ctx.fill();
                                ctx.stroke();
                                
                                const theoriesGenerated = Math.floor(discoveryPhase / 10);
                                const breakthroughsFound = discoveryPhase > 100 ? 1 : 0;
                                
                                ctx.font = '12px Aeonik, sans-serif';
                                ctx.fillStyle = '#202124';
                                ctx.fillText('Theories: ' + theoriesGenerated, 290, 440);
                                ctx.fillText('Tested: ' + theoriesGenerated, 290, 455);
                                ctx.fillText('Promising: ' + Math.floor(theoriesGenerated / 20), 290, 470);
                                ctx.fillStyle = '#4caf50';
                                ctx.font = 'bold 12px Aeonik, sans-serif';
                                ctx.fillText('Breakthroughs: ' + breakthroughsFound, 290, 490);
                            }
                            
                            function animate() {
                                if (isPaused) return;
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                // Draw components
                                drawEinsteinNotes();
                                drawFlowParticles();
                                drawAIProcessor();
                                drawTheorySpace();
                                drawStats();
                                
                                // Update animation state
                                animationFrame++;
                                discoveryPhase = (discoveryPhase + 0.5) % 150;
                                
                                requestAnimationFrame(animate);
                            }
                            
                            // Start animation
                            animate();
                        })();
                    </script>
                    
                    
                </section>

                <section class="section scroll-mt-20 no-print" id="appendix-e">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        9. Contributing to the Project
                    </h2>
                    
        
            
                    <div class="bg-blue-50 border-l-4 border-blue-600 p-6 rounded-r-lg mb-8 flex items-center gap-6">
                        <div>
                            <svg class="w-10 h-10 text-blue-500 inline-block mr-3" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4"/>
                            </svg>
                        </div>
                        <div>
                            <h4 class="text-lg font-semibold text-blue-800 mb-1 flex items-center gap-2">
                                <a href="https://github.com/pimdewitte/gravity-compression/" target="_blank" rel="noopener" class="inline-block text-physics-blue hover:underline font-medium">
                                    <svg class="w-5 h-5 inline-block" fill="currentColor" viewBox="0 0 24 24">
                                        <path d="M12 .5C5.73.5.5 5.73.5 12c0 5.08 3.29 9.39 7.86 10.91.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.34-1.3-1.7-1.3-1.7-1.06-.72.08-.71.08-.71 1.17.08 1.78 1.2 1.78 1.2 1.04 1.78 2.73 1.27 3.4.97.11-.75.41-1.27.74-1.56-2.56-.29-5.26-1.28-5.26-5.7 0-1.26.45-2.29 1.19-3.1-.12-.29-.52-1.46.11-3.05 0 0 .98-.31 3.2 1.18a11.1 11.1 0 0 1 2.92-.39c.99.01 1.99.13 2.92.39 2.22-1.49 3.2-1.18 3.2-1.18.63 1.59.23 2.76.11 3.05.74.81 1.19 1.84 1.19 3.1 0 4.43-2.7 5.41-5.27 5.7.42.36.79 1.09.79 2.2 0 1.59-.01 2.87-.01 3.26 0 .31.21.68.8.56C20.71 21.39 24 17.08 24 12c0-6.27-5.23-11.5-12-11.5z"/>
                                    </svg>
                                </a>
                            </h4>
                            <p class="text-sm text-blue-700">
                                The Gravity Compression codebase is <a href="https://github.com/pimdewitte/gravity-compression/" target="_blank" rel="noopener" class="text-physics-blue hover:underline font-medium">available on GitHub</a>.<br>
                            </p>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">🔬 Theory Development</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Propose new metric modifications</li>
                                <li>• Implement theories from literature</li>
                                <li>• Explore parameter spaces</li>
                                <li>• Validate physical constraints</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">💻 Code Improvements</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Optimize geodesic integration</li>
                                <li>• Add new loss metrics</li>
                                <li>• Improve caching system</li>
                                <li>• Enhance visualization tools</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">🤖 AI Enhancement</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Refine discovery prompts</li>
                                <li>• Add new LLM integrations</li>
                                <li>• Improve theory validation</li>
                                <li>• Develop learning algorithms</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">📚 Documentation</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Write tutorials</li>
                                <li>• Document discoveries</li>
                                <li>• Create visualizations</li>
                                <li>• Translate content</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section class="section scroll-mt-20" id="limitations">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">11. Limitations and Future Directions</h2>
                    <p>Our results are limited to classical scales within a GR-like framework. The promising signals from Linear Signal Loss require rigorous validation. Future work will: 1) Compare to astrophysical data. 2) Incorporate quantum effects. 3) Develop analytic derivations for top candidates. 4) Test against more diverse baselines.</p>
                </section>

                <section class="section scroll-mt-20" id="interactive-viz">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        7. Interactive Visualization System
                    </h2>
                    
                    <p class="text-base lg:text-lg leading-relaxed mb-6">
                        To facilitate deeper exploration and understanding of the generated theories, we have developed an interactive, browser-based 3D visualization system. This tool allows researchers to simulate particle trajectories in real-time under different metrics, adjust parameters on-the-fly, and observe quantum-like effects, all powered by WebGL for GPU acceleration.
                    </p>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-8 mb-4">Key Features</h3>
                    <ul class="list-disc list-inside space-y-3 text-base lg:text-lg mb-8">
                        <li><strong>Real-time Trajectory Simulation:</strong> Visualize multiple particles orbiting a central black hole with dynamic trails showing paths.</li>
                        <li><strong>Parameter Adjustment:</strong> Interactive sliders for theory parameters (e.g., α, γ) and quantum variables (e.g., noise strength for stochastic fluctuations).</li>
                        <li><strong>Quantum Effects:</strong> Simulate energy-based tests with random perturbations to velocities, colored by kinetic energy.</li>
                        <li><strong>Accessibility:</strong> Runs entirely in the browser—no installation required. Supports desktop and mobile devices.</li>
                    </ul>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-8 mb-4">How It Works</h3>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        For each evaluated theory, an interactive <code>viz.html</code> file is automatically generated in the theory's run directory (e.g., <code>runs/&lt;timestamp&gt;/&lt;category&gt;/&lt;theory_dir&gt;/viz.html</code>). This file loads the central <code>viz/visualization_enhanced.js</code> engine and embeds the theory's metric function converted to JavaScript.
                    </p>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        An example visualization for the 'Linear Signal Loss (γ=+1.00)' theory is available at the project root: <a href="../../../viz/example_viz.html" target="_blank" class="text-physics-blue hover:underline font-medium">viz/example_viz.html</a>. Open it in a browser to interact with the simulation.
                    </p>

                    <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg mb-6">
                        <p class="mb-0"><strong>📊 Getting Started:</strong> See the project README.md for detailed instructions on generating and using these visualizations. The source code is in <code>viz/visualization_enhanced.js</code>.</p>
                    </div>
                </section>

                <section class="section scroll-mt-20" id="black-hole-visualization">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        8. Interactive Black Hole Demonstration
                    </h2>
                    
                    <p class="text-base lg:text-lg leading-relaxed mb-6">
                        To provide an intuitive understanding of how the Compression Hypothesis manifests near extreme gravitational fields, we've developed an interactive 3D visualization of a black hole. This demonstration shows how reality's information compression intensifies as you approach the event horizon, where the universe's ability to maintain coherent 3D spacetime completely fails.
                    </p>

                    <div class="bg-blue-50 border-l-4 border-physics-blue p-6 rounded-r-lg mb-8">
                        <h3 class="text-lg font-semibold text-physics-blue mb-3">Key Features of the Visualization:</h3>
                        <ul class="list-disc list-inside space-y-2 text-sm lg:text-base">
                            <li><strong>Dynamic Distance Indicator:</strong> Shows your position in Schwarzschild radii (Rs) with real-time explanations of compression effects</li>
                            <li><strong>Interactive Elements:</strong> Click on glowing indicators to explore how particles, time, gravity, and space behave under extreme compression</li>
                            <li><strong>Event Horizon Approach:</strong> Navigate all the way to 1.35 Rs where a special modal explains why 3D visualization fails</li>
                            <li><strong>Visual Effects:</strong> Experience increasing distortion, chromatic aberration, and darkening as compression intensifies</li>
                        </ul>
                    </div>

                    <div class="relative w-full" style="padding-bottom: 75%; height: 0; min-height: 700px;">
                        <iframe 
                            src="interactive_black_hole.html" 
                            class="absolute top-0 left-0 w-full h-full border-2 border-gray-300 rounded-lg shadow-lg"
                            style="min-height: 700px;"
                            allow="fullscreen"
                            title="Interactive Black Hole Compression Demonstration">
                        </iframe>
                    </div>
                    
                    <div class="mt-8 bg-gray-50 border border-gray-200 rounded-lg p-6">
                        <h3 class="text-lg font-semibold text-physics-dark mb-3">Navigation Instructions:</h3>
                        <ul class="list-disc list-inside space-y-2 text-sm lg:text-base">
                            <li><strong>Rotate:</strong> Click and drag to orbit around the black hole</li>
                            <li><strong>Zoom:</strong> Scroll to approach or retreat from the event horizon</li>
                            <li><strong>Explore:</strong> Click the distance indicator at the top to see comprehensive information about Rs</li>
                            <li><strong>Interactive Elements:</strong> Click the glowing orbs (particles, time, gravity, space) for detailed explanations</li>
                            <li><strong>Auto-Rotate:</strong> Toggle automatic rotation in the bottom-right controls</li>
                        </ul>
                    </div>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-8 mb-4">8.1 Connection to Linear Signal Loss Theory</h3>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        This visualization directly demonstrates the core principle of our Linear Signal Loss model. As you approach the event horizon, notice how:
                    </p>
                    <ul class="list-disc list-inside space-y-3 text-base lg:text-lg mb-6">
                        <li>The "gravitational signal" degrades proportionally to your distance from Rs</li>
                        <li>Both gravitational and electromagnetic effects (represented by the interactive elements) degrade together</li>
                        <li>At the event horizon (1.0 Rs), information compression reaches 100%—the point where our unified field equations predict complete signal loss</li>
                        <li>The 3D→2D holographic transition represents the ultimate compression: an entire star's information reduced to just mass, charge, and spin</li>
                    </ul>

                    <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg mb-6">
                        <p class="mb-0"><strong>💡 Try This:</strong> Navigate to different distances and observe how the explanatory text changes. Pay special attention to the compression percentages—they follow the Linear Signal Loss formula where degradation increases as you approach Rs, matching our theoretical predictions of unified field behavior.</p>
                    </div>

                    <p class="text-base lg:text-lg leading-relaxed">
                        For the full immersive experience, <a href="interactive_black_hole.html" target="_blank" class="text-physics-blue hover:underline font-medium">open the visualization in a new tab</a>. The demonstration works on both desktop and mobile devices, though desktop provides the best interaction experience.
                    </p>
                </section>

                <section class="section scroll-mt-20" id="experimental-validation">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        10. Proposed Experimental Validation
                    </h2>
                    
                    <div class="responsive-table">
                        <table class="w-full border-collapse">
                            <thead>
                                <tr class="bg-gray-50">
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Test ID</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Scientific goal</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Primary datasets</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Toolchain & tips</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Est. GPU/CPU time</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Pass / fail criterion</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">S-1</td>
                                    <td class="px-4 py-3 border-b">Validate PPN-γ parameter in Linear Signal Loss vs Cassini data</td>
                                    <td class="px-4 py-3 border-b">1, 2</td>
                                    <td class="px-4 py-3 border-b">Use spiceypy for trajectory, poliastro for propagation; implement metric in PyTorch; fit γ by minimizing residuals against ODF data; filter plasma noise with solar angle >30°; use least-squares with lmfit</td>
                                    <td class="px-4 py-3 border-b">8 GPU-h</td>
                                    <td class="px-4 py-3 border-b">|γ-1| < 10^{-5} and loss ≤ GR baseline; balanced residuals vs RN simulation</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">S-3</td>
                                    <td class="px-4 py-3 border-b">Test Mercury perihelion precession and Shapiro delay in charged scenarios</td>
                                    <td class="px-4 py-3 border-b">2, 3, 5</td>
                                    <td class="px-4 py-3 border-b">Integrate geodesics with adaptive Runge-Kutta in PyTorch (float64); compare precession rate to MESSENGER data; simulate charged black hole analog; use CALCEPH for ephemerides</td>
                                    <td class="px-4 py-3 border-b">4 GPU-h</td>
                                    <td class="px-4 py-3 border-b">Precession match within 0.1% of observed; delay residuals ≤0.2m; similar accuracy for neutral/charged cases</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">S-5</td>
                                    <td class="px-4 py-3 border-b">Verify signal degradation effects in Juno solar conjunction data</td>
                                    <td class="px-4 py-3 border-b">2, 26</td>
                                    <td class="px-4 py-3 border-b">Compute two-way light-time with Linear Signal Loss metric; fit γ parameter to Ka-band residuals; compare to standard GR fit; process in batches of 1000 points</td>
                                    <td class="px-4 py-3 border-b">2 GPU-h</td>
                                    <td class="px-4 py-3 border-b">Residual std <1m; γ posterior peaks at 0.75-1.0 with balanced GR/RN losses</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">P-1</td>
                                    <td class="px-4 py-3 border-b">Test post-Keplerian parameters in binary pulsar timing</td>
                                    <td class="px-4 py-3 border-b">2, 6</td>
                                    <td class="px-4 py-3 border-b">Use TEMPO2 with custom metric plugin; fit PK parameters including orbital decay; compare energy loss to GR prediction; run MCMC with 10^5 samples</td>
                                    <td class="px-4 py-3 border-b">6 GPU-h</td>
                                    <td class="px-4 py-3 border-b">Energy loss within 0.1% of GR; similar for charged pulsar analog; loss ratio GR/RN >0.9</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">P-5</td>
                                    <td class="px-4 py-3 border-b">Analyze GW ringdown for information loss signatures</td>
                                    <td class="px-4 py-3 border-b">8</td>
                                    <td class="px-4 py-3 border-b">Modify pyRing to include γ-dependent damping; fit to O3 events; compute Bayes factor vs standard GR; parallel process 10 events</td>
                                    <td class="px-4 py-3 border-b">12 GPU-h</td>
                                    <td class="px-4 py-3 border-b">Evidence for γ>0 at >3σ; consistent τ across events; balanced with EM-like dispersion</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">P-6</td>
                                    <td class="px-4 py-3 border-b">Test anomalous acceleration in PSR J2043+1711 for Linear Signal Loss signatures</td>
                                    <td class="px-4 py-3 border-b">NANOGrav 15-yr dataset (PSR J2043+1711 timing residuals)</td>
                                    <td class="px-4 py-3 border-b">Download NANOGrav 15-yr data; implement metric in PyTorch; fit γ to residuals using TEMPO2 with custom plugin; compare precession deviations to GR baseline; run MCMC with 10^5 samples; use enterprise for noise modeling</td>
                                    <td class="px-4 py-3 border-b">8 GPU-h</td>
                                    <td class="px-4 py-3 border-b">Acceleration match within 0.5σ of observed; better fit (Δχ² > 5) than GR; balanced GR/RN losses</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <p class="text-base lg:text-lg leading-relaxed mt-6">
                        These tests focus on validating the core claims of balanced losses and unification signals in Linear Signal Loss theory. Each test includes specific instructions for implementation, focusing on computational verification against real datasets.
                    </p>
                </section>
            </main>
        </div>
    </div>

    <!-- Scripts -->
    <script>
        // Mobile menu functionality
        const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
        const mobileMenuClose = document.getElementById('mobile-menu-close');
        const mobileMenu = document.getElementById('mobile-menu');
        
        if (mobileMenuToggle) {
            mobileMenuToggle.addEventListener('click', () => {
                mobileMenu.classList.remove('translate-x-full');
            });
        }
        
        if (mobileMenuClose) {
            mobileMenuClose.addEventListener('click', () => {
                mobileMenu.classList.add('translate-x-full');
            });
        }
        
        // Close mobile menu when clicking a link
        document.querySelectorAll('#mobile-menu a').forEach(link => {
            link.addEventListener('click', () => {
                mobileMenu.classList.add('translate-x-full');
            });
        });
        
        // Smooth scroll offset for fixed header
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const offset = window.innerWidth < 1024 ? 80 : 20; // Different offset for mobile vs desktop
                    const targetPosition = target.offsetTop - offset;
                    window.scrollTo({
                        top: targetPosition,
                        behavior: 'smooth'
                    });
                }
            });
        });
        
        // Active section highlighting in navigation
        const sections = document.querySelectorAll('section[id]');
        const navLinks = document.querySelectorAll('nav a[href^="#"]');
        
        function highlightActiveSection() {
            const scrollY = window.pageYOffset;
            
            sections.forEach(section => {
                const sectionHeight = section.offsetHeight;
                const sectionTop = section.offsetTop - 100;
                const sectionId = section.getAttribute('id');
                
                if (scrollY > sectionTop && scrollY <= sectionTop + sectionHeight) {
                    navLinks.forEach(link => {
                        link.classList.remove('bg-blue-100', 'text-physics-blue', 'font-medium');
                        if (link.getAttribute('href') === `#${sectionId}`) {
                            link.classList.add('bg-blue-100', 'text-physics-blue', 'font-medium');
                        }
                    });
                }
            });
        }
        
        window.addEventListener('scroll', highlightActiveSection);
        highlightActiveSection(); // Initial check
        
        // Lightbox functions removed - images now open in new tabs
        
        // Lightbox setup removed - images open in new tabs
        
        // Images now open in new tabs - no need for click handlers
        
        // ESC key handler removed - lightbox no longer exists
        
        // Responsive table wrapper
        document.querySelectorAll('table').forEach(table => {
            if (!table.closest('.responsive-table')) {
                const wrapper = document.createElement('div');
                wrapper.className = 'responsive-table overflow-x-auto';
                table.parentNode.insertBefore(wrapper, table);
                wrapper.appendChild(table);
                table.className = 'min-w-full border-collapse text-sm lg:text-base';
            }
        });
        
        // Initialize collapsible tables
        function setupCollapsibleTables() {
            document.querySelectorAll('.collapsible-table').forEach(table => {
                const rows = Array.from(table.querySelectorAll('tbody > tr'));
                if (rows.length > 5) {
                    for (let i = 5; i < rows.length; i++) {
                        rows[i].classList.add('collapsible-row');
                    }

                    let tfoot = table.querySelector('tfoot');
                    if (!tfoot) {
                        tfoot = document.createElement('tfoot');
                        table.appendChild(tfoot);
                    }
                    
                    const colCount = table.querySelector('thead tr').children.length;
                    tfoot.innerHTML = `
                        <tr>
                            <td colspan="${colCount}" class="p-0">
                                <button class="w-full bg-gray-50 hover:bg-gray-100 px-4 py-3 text-center text-physics-blue font-medium transition-colors">
                                    Show More (${rows.length - 5} rows)
                                </button>
                            </td>
                        </tr>
                    `;

                    const button = tfoot.querySelector('button');
                    button.addEventListener('click', () => {
                        table.classList.toggle('expanded');
                        if (table.classList.contains('expanded')) {
                            button.textContent = 'Show Less';
                            // Show associated charts if any
                            if (table.id === 'results-table') {
                                const chartContainer = document.getElementById('results-chart-container');
                                const chartCaption = document.getElementById('results-chart-caption');
                                if (chartContainer) chartContainer.style.display = 'block';
                                if (chartCaption) chartCaption.style.display = 'block';
                            }
                        } else {
                            button.textContent = `Show More (${rows.length - 5} rows)`;
                            // Hide associated charts if any
                            if (table.id === 'results-table') {
                                const chartContainer = document.getElementById('results-chart-container');
                                const chartCaption = document.getElementById('results-chart-caption');
                                if (chartContainer) chartContainer.style.display = 'none';
                                if (chartCaption) chartCaption.style.display = 'none';
                            }
                        }
                    });
                }
            });
        }
        
        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            setupCollapsibleTables();
            populateAppendix();
            populateEinsteinTable();
            
            // Initialize charts if present
            const resultsCtx = document.getElementById('resultsChart');
            if (resultsCtx) {
                // Chart initialization code here
            }
        });

        // Table population functions
        function populateAppendix() {
            // This function can be used to populate any appendix tables if needed
        }

        function populateEinsteinTable() {
            const tableBody = document.querySelector('#einstein-theories-table tbody');
            if (!tableBody) return;
            
            const theories = [
                {
                    name: "Einstein Unified (α=0.5)",
                    modification: "g_tφ = α(r_s/r)² sin²θ",
                    basis: "Non-symmetric metric with angular momentum coupling"
                },
                {
                    name: "Einstein Final",
                    modification: "g_tt = -(1 - r_s/r)(1 + α/r²)",
                    basis: "Deathbed calculations suggesting electromagnetic unification"
                },
                {
                    name: "Kaluza-Klein Geometric",
                    modification: "g_55 = φ²(r), where φ is 5th dimension scale",
                    basis: "5D unification approach Einstein explored"
                },
                {
                    name: "Einstein Torsion",
                    modification: "S^λ_μν = α(δ^λ_μ∂_ν - δ^λ_ν∂_μ)φ",
                    basis: "Torsion field from asymmetric connection"
                },
                {
                    name: "Teleparallel",
                    modification: "T^λ_μν = e^λ_a(∂_μe^a_ν - ∂_νe^a_μ)",
                    basis: "Teleparallel gravity Einstein investigated late in life"
                },
                {
                    name: "Einstein Non-Symmetric",
                    modification: "g_[μν] = α F_μν, where F is EM field",
                    basis: "Antisymmetric part encoding electromagnetism"
                },
                {
                    name: "Affine Connection",
                    modification: "Γ^λ_μν ≠ {^λ_μν}, non-metric connection",
                    basis: "Generalized affine connection theory"
                },
                {
                    name: "Einstein-Kaluza Unified",
                    modification: "g_μ5 = κ A_μ, where A is EM potential",
                    basis: "5D metric with electromagnetic potential"
                }
            ];
            
            theories.forEach(theory => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50';
                row.innerHTML = `
                    <td class="px-4 py-3 border-b font-medium">${theory.name}</td>
                    <td class="px-4 py-3 border-b font-mono text-sm">${theory.modification}</td>
                    <td class="px-4 py-3 border-b text-sm">${theory.basis}</td>
                `;
                tableBody.appendChild(row);
            });
        }
    </script>
</body>
</html>