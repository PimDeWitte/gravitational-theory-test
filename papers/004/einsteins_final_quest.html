<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Einstein's Final Quest as an RL Problem: Self-Generating Physics</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    
    
    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', '-apple-system', 'sans-serif'],
                        'mono': ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        'physics-blue': '#1a0dab',
                        'physics-light-blue': '#4285f4',
                        'physics-dark': '#202124',
                        'physics-gray': '#5f6368',
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Custom Aeonik Font */
        @font-face {
            font-family: 'Aeonik';
            src: url('https://cdn.jsdelivr.net/gh/juliusgarbe/aeonik-fonts@main/Aeonik-Regular.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
        }
        @font-face {
            font-family: 'Aeonik';
            src: url('https://cdn.jsdelivr.net/gh/juliusgarbe/aeonik-fonts@main/Aeonik-Medium.woff2') format('woff2');
            font-weight: 500;
            font-style: normal;
        }
        @font-face {
            font-family: 'Aeonik';
            src: url('https://cdn.jsdelivr.net/gh/juliusgarbe/aeonik-fonts@main/Aeonik-Bold.woff2') format('woff2');
            font-weight: 700;
            font-style: normal;
        }
        
        /* Use Aeonik for headings */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Aeonik', 'Inter', sans-serif;
        }
        
        /* Smooth scroll */
        html {
            scroll-behavior: smooth;
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Math variables styling */
        .math-var {
            font-family: 'Times New Roman', 'Georgia', serif;
            font-style: italic;
            color: #1a0dab;
            font-size: 1.05em;
        }
        
        /* Formula display */
        .formula-display {
            @apply text-center text-physics-blue bg-blue-50 py-6 px-8 rounded-xl my-6 mx-auto;
            font-family: 'Times New Roman', 'Georgia', serif;
            font-size: 1.4rem;
            width: fit-content;
            min-width: 300px;
            box-shadow: 0 2px 8px rgba(26, 13, 171, 0.08);
            border: 1px solid #e0e7ff;
            position: relative;
        }
        
        .formula-display:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #1a0dab, #4285f4);
            border-radius: 12px 12px 0 0;
        }
        
        /* Story blockquote */
        .story-blockquote {
            @apply border-l-4 border-physics-light-blue pl-6 my-8 text-lg italic text-gray-700;
            font-family: 'Aeonik', 'Inter', sans-serif;
            line-height: 1.8;
        }
        
        /* Responsive canvas */
        @media (max-width: 768px) {
            canvas {
                max-width: 100% !important;
                height: auto !important;
            }
            
            .formula-display {
                font-size: 1.1rem;
                padding: 1.5rem 1rem;
                min-width: auto;
                width: 100%;
            }
        }
        
        /* Iframe container styling */
        .iframe-container {
            position: relative;
            width: 100%;
            padding-bottom: 75%; /* 4:3 aspect ratio for better visualization */
            height: 0;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            min-height: 700px;
        }
        
        .iframe-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            min-height: 700px;
        }
        
        @media (max-width: 768px) {
            .iframe-container {
                padding-bottom: 100%; /* Square on mobile */
                min-height: 500px;
            }
            .iframe-container iframe {
                min-height: 500px;
            }
        }
        
        /* Table improvements */
        .responsive-table {
            @apply w-full overflow-x-auto;
        }
        
        .responsive-table table {
            @apply min-w-full;
        }
        
        /* Mobile-first approach for tables */
        @media (max-width: 640px) {
            .responsive-table table {
                @apply text-sm;
            }
            
            .responsive-table th,
            .responsive-table td {
                @apply px-2 py-1;
            }
        }
        
        /* Animation classes */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        /* Collapsible table styling */
        .collapsible-table .collapsible-row {
            display: none;
        }
        .collapsible-table.expanded .collapsible-row {
            display: table-row;
        }
        
        /* Lightbox removed - images open in new tabs */
        
        /* Print styles */
        @media print {
            .no-print {
                display: none !important;
            }
            
            body {
                font-size: 12pt;
            }
            
            h1 { font-size: 24pt; }
            h2 { font-size: 20pt; }
            h3 { font-size: 16pt; }
        }
    </style>
</head>
<body class="bg-white text-physics-dark antialiased">

    <!-- Mobile Navigation -->
    <nav class="lg:hidden fixed top-0 left-0 right-0 bg-white shadow-md z-40 no-print">
        <div class="flex items-center justify-between px-4 py-3">
            <h2 class="text-lg font-semibold text-physics-blue">Einstein's Final Quest as an RL Problem</h2>
            <button id="mobile-menu-toggle" class="p-2 rounded-md hover:bg-gray-100">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
            </button>
        </div>
    </nav>
    
    <!-- Mobile Menu -->
    <div id="mobile-menu" class="lg:hidden fixed inset-0 bg-white z-50 transform translate-x-full transition-transform duration-300 no-print">
        <div class="p-4">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-semibold">Navigation</h3>
                <button id="mobile-menu-close" class="p-2 rounded-md hover:bg-gray-100">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <nav class="space-y-2">
                <a href="#abstract" class="block py-2 px-4 rounded hover:bg-gray-100">Abstract</a>
                <a href="#einstein-rl" class="block py-2 px-4 rounded hover:bg-gray-100">1. The RL Formulation</a>
                <a href="#framework" class="block py-2 px-4 rounded hover:bg-gray-100">2. Building Blocks</a>
                <a href="#self-discovery" class="block py-2 px-4 rounded hover:bg-gray-100">3. self_discovery.py</a>
                <a href="#prediction-game" class="block py-2 px-4 rounded hover:bg-gray-100">4. Prediction Pipeline</a>
                <a href="#tested-theories" class="block py-2 px-4 rounded hover:bg-gray-100">5. AI-Generated Theories</a>
                <a href="#interactive-viz" class="block py-2 px-4 rounded hover:bg-gray-100">6. Interactive Visualization</a>
                <a href="#black-hole-visualization" class="block py-2 px-4 rounded hover:bg-gray-100">7. Black Hole Demo</a>
                <a href="#appendix-e" class="block py-2 px-4 rounded hover:bg-gray-100">8. Contributing</a>
                <a href="#experimental-validation" class="block py-2 px-4 rounded hover:bg-gray-100">9. Experimental Validation</a>
                <a href="#conclusion" class="block py-2 px-4 rounded hover:bg-gray-100">10. Conclusion</a>
                <a href="#critical-review" class="block py-2 px-4 rounded hover:bg-gray-100">11. Critical Review</a>
            </nav>
        </div>
    </div>
    
    <!-- Desktop Navigation -->
    <nav class="hidden lg:block fixed left-0 top-0 h-full w-64 bg-gray-50 border-r border-gray-200 overflow-y-auto no-print">
        <div class="p-6">
            <h3 class="text-lg font-semibold text-physics-blue mb-4">Navigation</h3>
            <nav class="space-y-1">
                <a href="#abstract" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">Abstract</a>
                <a href="#einstein-rl" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">1. The RL Formulation</a>
                <a href="#framework" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">2. Building Blocks</a>
                <a href="#self-discovery" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">3. self_discovery.py</a>
                <a href="#prediction-game" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">4. Prediction Pipeline</a>
                <a href="#tested-theories" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">5. AI-Generated Theories</a>
                <a href="#interactive-viz" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">6. Interactive Visualization</a>
                <a href="#black-hole-visualization" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">7. Black Hole Demo</a>
                <a href="#appendix-e" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">8. Contributing</a>
                <a href="#experimental-validation" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">9. Experimental Validation</a>
                <a href="#conclusion" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">10. Conclusion</a>
                <a href="#critical-review" class="block py-2 px-3 rounded hover:bg-gray-200 text-sm">11. Critical Review</a>
            </nav>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="lg:ml-64 pt-16 lg:pt-0">
        <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-8 lg:py-12">

            <!-- Header -->
            <header class="mb-12 lg:mb-16 fade-in">
                <h1 class="text-3xl sm:text-4xl lg:text-5xl xl:text-6xl font-bold tracking-tight mb-4 lg:mb-6 text-physics-blue leading-tight">
                    Einstein's Final Quest as an RL Problem:<br>
                    Self-Generating Physics
                </h1>
                <p class="text-lg lg:text-xl text-physics-gray leading-relaxed max-w-4xl">
                    An autonomous reinforcement learning system for gravitational theory discovery:<br>
                    From idea → theory → observation → prediction → future prediction
                </p>
                <div class="mt-6 space-y-1 text-physics-gray">
                    <p class="font-medium">W.W.A. (Pim) de Witte, General Intuition PBC</p>
                    <p>pim@generalintuition.ai</p>
                    <p class="text-sm mt-2">July 10, 2025</p>
                </div>
            </header>

            <!-- Abstract -->
            <div id="abstract" class="bg-blue-50 border-l-4 border-physics-blue p-6 lg:p-8 rounded-r-lg mb-12 fade-in scroll-mt-20">
                <h2 class="text-2xl lg:text-3xl font-bold text-physics-blue mb-4">Abstract</h2>
                <div class="space-y-4 text-base lg:text-lg leading-relaxed">
                    <p>
                        We present a reinforcement learning (RL) system that autonomously generates and tests gravitational theories. The system in `self_discovery.py` implements a complete RL loop where an AI agent (Grok-4) generates Python code for new metric tensors, evaluates them through geodesic simulations, and iteratively improves based on multi-objective rewards.
                    </p>
                    <p>
                        The pipeline transforms ideas into executable theories, tests against observations (Mercury precession, pulsar timing), and makes future predictions. Each iteration updates the policy via prompt engineering, creating a self-improving system that explores the infinite space of possible gravitational theories guided by Einstein's geometric insights.
                    </p>
                </div>
            </div>

            <!-- Main Content Continues -->
            <main class="space-y-12 lg:space-y-16">

                <!-- Section 1: The RL Formulation -->
                <section class="section scroll-mt-20" id="einstein-rl">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        1. The RL Formulation: Autonomous Theory Discovery
                    </h2>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start mb-8">
                        <div class="space-y-6">
                            <p class="text-base lg:text-lg leading-relaxed">
                                We transform Einstein's quest into a reinforcement learning problem where an AI agent learns to generate gravitational theories that maximize predictive accuracy. The system operates autonomously, generating new theories as Python code and evaluating them through physics simulations.
                            </p>
                            
                            <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                                <h4 class="font-semibold text-physics-blue mb-3">RL Components</h4>
                                <ul class="text-sm lg:text-base space-y-2">
                                    <li><strong>State:</strong> History of generated theories + validation results</li>
                                    <li><strong>Action:</strong> Generate new metric tensor g_μν as Python code</li>
                                    <li><strong>Environment:</strong> PyTorch geodesic simulator</li>
                                    <li><strong>Reward:</strong> -FFT_loss + validation_accuracy</li>
                                    <li><strong>Policy:</strong> LLM (Grok-4) with history-dependent prompting</li>
                                </ul>
                            </div>
                            
                            <p class="text-base lg:text-lg leading-relaxed">
                                The agent starts with Einstein's final notes (non-symmetric metrics, torsion) as context, then generates variations and entirely new structures. Each theory is automatically converted to executable code, tested, and fed back into the next generation cycle.
                            </p>
                        </div>
                        
                        <div class="lg:sticky lg:top-8">
                            <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                <canvas id="rlFlowDiagram" class="w-full" width="420" height="600"></canvas>
                                <p class="text-sm text-center text-physics-gray mt-4">Complete RL Flow: Idea → Theory → Observation → Prediction → Future. Click to animate.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- New comprehensive flow diagram -->
                    <script>
                        (function() {
                            const canvas = document.getElementById('rlFlowDiagram');
                            const ctx = canvas.getContext('2d');
                            let animationFrame = 0;
                            let isPaused = false;
                            let currentStage = 0;
                            let particleSystem = [];
                            
                            // Initialize particles
                            for (let i = 0; i < 30; i++) {
                                particleSystem.push({
                                    x: Math.random() * canvas.width,
                                    y: Math.random() * canvas.height,
                                    vx: (Math.random() - 0.5) * 0.5,
                                    vy: (Math.random() - 0.5) * 0.5,
                                    size: Math.random() * 2 + 0.5,
                                    opacity: Math.random() * 0.3 + 0.1
                                });
                            }
                            
                            canvas.addEventListener('click', () => {
                                isPaused = !isPaused;
                                if (!isPaused) animate();
                            });
                            
                            // Add roundRect polyfill
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                            const stages = [
                                {
                                    name: "1. IDEA",
                                    y: 50,
                                    color: "#1a73e8",
                                    detail: "Einstein's notes + AI creativity",
                                    example: "What if g_tφ ≠ 0?"
                                },
                                {
                                    name: "2. THEORY",
                                    y: 140,
                                    color: "#2196f3",
                                    detail: "Generate Python code",
                                    example: "class TorsionGravity(GravitationalTheory)..."
                                },
                                {
                                    name: "3. OBSERVATION",
                                    y: 230,
                                    color: "#00bcd4",
                                    detail: "Simulate geodesics",
                                    example: "10^5 integration steps"
                                },
                                {
                                    name: "4. PREDICTION",
                                    y: 320,
                                    color: "#4caf50",
                                    detail: "Match known phenomena",
                                    example: "Mercury: 43\"/century"
                                },
                                {
                                    name: "5. FUTURE",
                                    y: 410,
                                    color: "#ff9800",
                                    detail: "Novel predictions",
                                    example: "Pulsar anomaly at 10^-15"
                                },
                                {
                                    name: "6. REWARD",
                                    y: 500,
                                    color: "#9c27b0",
                                    detail: "Update policy",
                                    example: "Loss: 0.157 → History"
                                }
                            ];
                            
                            function drawBackground() {
                                // Subtle grid
                                ctx.strokeStyle = '#f0f0f0';
                                ctx.lineWidth = 0.5;
                                for (let x = 0; x < canvas.width; x += 20) {
                                    ctx.beginPath();
                                    ctx.moveTo(x, 0);
                                    ctx.lineTo(x, canvas.height);
                                    ctx.stroke();
                                }
                                for (let y = 0; y < canvas.height; y += 20) {
                                    ctx.beginPath();
                                    ctx.moveTo(0, y);
                                    ctx.lineTo(canvas.width, y);
                                    ctx.stroke();
                                }
                                
                                // Particles
                                particleSystem.forEach(p => {
                                    p.x += p.vx;
                                    p.y += p.vy;
                                    if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                                    if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
                                    
                                    ctx.fillStyle = `rgba(66, 133, 244, ${p.opacity})`;
                                    ctx.beginPath();
                                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                                    ctx.fill();
                                });
                            }
                            
                            function drawStage(stage, index) {
                                const x = 60;
                                const width = 300;
                                const height = 70;
                                const isActive = currentStage >= index;
                                const isCurrent = currentStage === index;
                                
                                // Connection to next stage
                                if (index < stages.length - 1) {
                                    const nextStage = stages[index + 1];
                                    const progress = isActive ? 1 : 0;
                                    
                                    if (progress > 0) {
                                        // Animated arrow
                                        ctx.strokeStyle = stage.color;
                                        ctx.lineWidth = 2;
                                        ctx.setLineDash([5, 5]);
                                        ctx.lineDashOffset = -animationFrame * 0.5;
                                        
                                        ctx.beginPath();
                                        ctx.moveTo(x + width/2, stage.y + height/2);
                                        ctx.lineTo(x + width/2, nextStage.y - height/2);
                                        ctx.stroke();
                                        
                                        ctx.setLineDash([]);
                                        
                                        // Arrowhead
                                        ctx.fillStyle = stage.color;
                                        ctx.beginPath();
                                        ctx.moveTo(x + width/2, nextStage.y - height/2);
                                        ctx.lineTo(x + width/2 - 5, nextStage.y - height/2 - 10);
                                        ctx.lineTo(x + width/2 + 5, nextStage.y - height/2 - 10);
                                        ctx.closePath();
                                        ctx.fill();
                                    }
                                }
                                
                                // Stage box
                                ctx.fillStyle = isActive ? stage.color : '#f8f9fa';
                                ctx.strokeStyle = stage.color;
                                ctx.lineWidth = isCurrent ? 3 : 1;
                                
                                if (isCurrent) {
                                    // Glow effect
                                    ctx.shadowColor = stage.color;
                                    ctx.shadowBlur = 20;
                                }
                                
                                ctx.beginPath();
                                ctx.roundRect(x, stage.y - height/2, width, height, 10);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.shadowBlur = 0;
                                
                                // Stage number and name
                                ctx.fillStyle = isActive ? '#ffffff' : stage.color;
                                ctx.font = 'bold 16px Aeonik, sans-serif';
                                ctx.textAlign = 'left';
                                ctx.fillText(stage.name, x + 20, stage.y - 10);
                                
                                // Detail
                                ctx.font = '12px Aeonik, sans-serif';
                                ctx.fillStyle = isActive ? '#ffffff' : '#5f6368';
                                ctx.fillText(stage.detail, x + 20, stage.y + 5);
                                
                                // Example
                                ctx.font = '11px JetBrains Mono, monospace';
                                ctx.fillStyle = isActive ? 'rgba(255,255,255,0.8)' : '#7f8c8d';
                                ctx.fillText(stage.example, x + 20, stage.y + 20);
                                
                                // Progress indicator
                                if (isCurrent) {
                                    const progressWidth = width - 40;
                                    const progressX = x + 20;
                                    const progressY = stage.y + 30;
                                    
                                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                                    ctx.fillRect(progressX, progressY, progressWidth, 4);
                                    
                                    const fillWidth = progressWidth * ((animationFrame % 100) / 100);
                                    ctx.fillStyle = '#ffffff';
                                    ctx.fillRect(progressX, progressY, fillWidth, 4);
                                }
                            }
                            
                            function drawRLLoop() {
                                // Loop back arrow from REWARD to IDEA
                                if (currentStage === stages.length - 1) {
                                    ctx.strokeStyle = '#9c27b0';
                                    ctx.lineWidth = 2;
                                    ctx.setLineDash([5, 5]);
                                    ctx.lineDashOffset = -animationFrame * 0.5;
                                    
                                    ctx.beginPath();
                                    ctx.moveTo(60 + 300, stages[5].y);
                                    ctx.quadraticCurveTo(
                                        380, stages[5].y,
                                        380, (stages[5].y + stages[0].y) / 2
                                    );
                                    ctx.quadraticCurveTo(
                                        380, stages[0].y,
                                        360, stages[0].y
                                    );
                                    ctx.stroke();
                                    
                                    ctx.setLineDash([]);
                                    
                                    // Arrow pointing to IDEA
                                    ctx.fillStyle = '#9c27b0';
                                    ctx.beginPath();
                                    ctx.moveTo(360, stages[0].y);
                                    ctx.lineTo(370, stages[0].y - 5);
                                    ctx.lineTo(370, stages[0].y + 5);
                                    ctx.closePath();
                                    ctx.fill();
                                    
                                    // Loop label
                                    ctx.font = 'bold 12px Aeonik, sans-serif';
                                    ctx.fillStyle = '#9c27b0';
                                    ctx.textAlign = 'center';
                                    ctx.fillText('RL LOOP', 380, (stages[5].y + stages[0].y) / 2);
                                }
                            }
                            
                            function drawCodeGeneration() {
                                // Show code generation in action when at THEORY stage
                                if (currentStage === 1) {
                                    const codeX = 100;
                                    const codeY = stages[1].y + 50;
                                    
                                    ctx.fillStyle = 'rgba(33, 150, 243, 0.1)';
                                    ctx.strokeStyle = '#2196f3';
                                    ctx.lineWidth = 1;
                                    ctx.beginPath();
                                    ctx.roundRect(codeX, codeY, 220, 80, 5);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    ctx.font = '10px JetBrains Mono, monospace';
                                    ctx.fillStyle = '#1976d2';
                                    const code = [
                                        'def get_metric(self, r, M, c, G):',
                                        '    rs = 2 * G * M / c**2',
                                        '    g_tt = -(1 - rs/r)',
                                        '    g_tp = alpha * (rs/r)**2',
                                        '    return g_tt, 1/(1-rs/r), r**2, g_tp'
                                    ];
                                    code.forEach((line, i) => {
                                        const chars = Math.min(line.length, Math.floor((animationFrame % 100) / 2));
                                        ctx.fillText(line.substring(0, chars) + (chars < line.length ? '|' : ''), codeX + 10, codeY + 15 + i * 12);
                                    });
                                }
                            }
                            
                            function animate() {
                                if (isPaused) return;
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                drawBackground();
                                
                                // Draw all stages
                                stages.forEach((stage, index) => {
                                    drawStage(stage, index);
                                });
                                
                                drawRLLoop();
                                drawCodeGeneration();
                                
                                // Update animation
                                animationFrame++;
                                if (animationFrame % 150 === 0) {
                                    currentStage = (currentStage + 1) % stages.length;
                                }
                                
                                requestAnimationFrame(animate);
                            }
                            
                            // Start animation
                            animate();
                        })();
                    </script>
                </section>

                <!-- Section 2: Building Blocks -->
                <section class="section scroll-mt-20" id="framework">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        2. Building Blocks: The Technical Architecture
                    </h2>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                        <div class="space-y-6">
                            <p class="text-base lg:text-lg leading-relaxed">
                                The system consists of three core components working in concert:
                            </p>
                            
                            <div class="space-y-4">
                                <div class="bg-blue-50 border-l-4 border-blue-600 p-4">
                                    <h4 class="font-semibold text-blue-800 mb-2">1. Theory Generator (Grok-4 API)</h4>
                                    <p class="text-sm">Generates Python classes inheriting from GravitationalTheory. Each class implements get_metric() returning (g_tt, g_rr, g_pp, g_tp) as PyTorch tensors.</p>
                                </div>
                                
                                <div class="bg-green-50 border-l-4 border-green-600 p-4">
                                    <h4 class="font-semibold text-green-800 mb-2">2. Physics Simulator (PyTorch)</h4>
                                    <p class="text-sm">Computes Christoffel symbols via automatic differentiation, integrates geodesic equations using RK4 with O(Δτ⁵) accuracy.</p>
                                </div>
                                
                                <div class="bg-purple-50 border-l-4 border-purple-600 p-4">
                                    <h4 class="font-semibold text-purple-800 mb-2">3. Reward Calculator</h4>
                                    <p class="text-sm">FFT-based trajectory comparison + astronomical validation tests. Multi-objective rewards guide exploration.</p>
                                </div>
                            </div>
                            
                            <p class="text-base lg:text-lg leading-relaxed">
                                Key innovation: The entire pipeline is differentiable and GPU-accelerated, enabling 10⁶ integration steps per second on modern hardware.
                            </p>
                        </div>
                        
                        <div class="lg:sticky lg:top-8">
                            <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                <canvas id="theoryGenerationCanvas" class="w-full" width="420" height="500"></canvas>
                                <p class="text-sm text-center text-physics-gray mt-4">Live Theory Generation: Watch the AI create new physics. Click to pause.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Theory generation animation -->
                    <script>
                        (function() {
                            const canvas = document.getElementById('theoryGenerationCanvas');
                            const ctx = canvas.getContext('2d');
                            let animationFrame = 0;
                            let isPaused = false;
                            let generationPhase = 0; // 0: prompt, 1: generating, 2: testing, 3: result
                            
                            canvas.addEventListener('click', () => {
                                isPaused = !isPaused;
                                if (!isPaused) animate();
                            });
                            
                            // Add roundRect polyfill
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                            const exampleTheories = [
                                {
                                    name: "TorsionFieldGravity",
                                    idea: "Non-symmetric metric with g_tφ ≠ 0",
                                    code: [
                                        "class TorsionFieldGravity(GravitationalTheory):",
                                        "    def __init__(self, alpha=0.1):",
                                        "        super().__init__('TorsionField')",
                                        "        self.alpha = alpha",
                                        "",
                                        "    def get_metric(self, r, M, c, G):",
                                        "        rs = 2 * G * M / c**2",
                                        "        g_tt = -(1 - rs/r)",
                                        "        g_rr = 1/(1 - rs/r)",
                                        "        g_pp = r**2",
                                        "        g_tp = self.alpha * (rs/r)**2",
                                        "        return g_tt, g_rr, g_pp, g_tp"
                                    ],
                                    loss: 0.234
                                },
                                {
                                    name: "QuantumCorrectedGR",
                                    idea: "Add Planck-scale corrections",
                                    code: [
                                        "class QuantumCorrectedGR(GravitationalTheory):",
                                        "    def __init__(self, beta=1.0):",
                                        "        super().__init__('QuantumGR')",
                                        "        self.beta = beta",
                                        "",
                                        "    def get_metric(self, r, M, c, G):",
                                        "        rs = 2 * G * M / c**2",
                                        "        lp = 1.616e-35  # Planck length",
                                        "        quantum_term = self.beta * (lp/r)**2",
                                        "        g_tt = -(1 - rs/r + quantum_term)",
                                        "        g_rr = 1/(1 - rs/r + quantum_term)",
                                        "        return g_tt, g_rr, r**2, 0"
                                    ],
                                    loss: 0.412
                                }
                            ];
                            
                            let currentTheoryIndex = 0;
                            const currentTheory = () => exampleTheories[currentTheoryIndex % exampleTheories.length];
                            
                            function drawPromptPhase() {
                                // Title
                                ctx.font = 'bold 16px Aeonik, sans-serif';
                                ctx.fillStyle = '#1a0dab';
                                ctx.textAlign = 'center';
                                ctx.fillText('Step 1: Building Prompt', 210, 30);
                                
                                // History box
                                ctx.fillStyle = '#f8f9fa';
                                ctx.strokeStyle = '#dadce0';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.roundRect(20, 50, 380, 120, 8);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.font = '11px Aeonik, sans-serif';
                                ctx.fillStyle = '#5f6368';
                                ctx.textAlign = 'left';
                                ctx.fillText('Previous results:', 30, 70);
                                
                                ctx.font = '10px JetBrains Mono, monospace';
                                ctx.fillStyle = '#202124';
                                const history = [
                                    'SchwarzschildGR: Pure gravity baseline, loss=0.000',
                                    'ReissnerNordstrom: Gravity+EM, loss=0.000',
                                    'AsymmetricMetric: g_μν ≠ g_νμ, loss=0.567',
                                    'KaluzaKlein5D: Extra dimension, loss=0.891'
                                ];
                                history.forEach((line, i) => {
                                    ctx.fillText(line, 30, 90 + i * 15);
                                });
                                
                                // Prompt construction
                                ctx.fillStyle = '#e8f0fe';
                                ctx.strokeStyle = '#1976d2';
                                ctx.beginPath();
                                ctx.roundRect(20, 190, 380, 100, 8);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.font = '11px Aeonik, sans-serif';
                                ctx.fillStyle = '#1976d2';
                                ctx.fillText('New prompt:', 30, 210);
                                
                                ctx.font = '10px JetBrains Mono, monospace';
                                ctx.fillStyle = '#0d47a1';
                                const prompt = [
                                    '"Previous asymmetric metric showed promise.',
                                    'Try adding torsion term g_tφ inspired by',
                                    'Einstein\'s 1955 notes. Use α parameter."'
                                ];
                                prompt.forEach((line, i) => {
                                    const chars = Math.min(line.length, Math.floor((animationFrame % 150) / 2));
                                    ctx.fillText(line.substring(0, chars), 30, 230 + i * 15);
                                });
                            }
                            
                            function drawGeneratingPhase() {
                                // Title
                                ctx.font = 'bold 16px Aeonik, sans-serif';
                                ctx.fillStyle = '#2196f3';
                                ctx.textAlign = 'center';
                                ctx.fillText('Step 2: AI Generating Code', 210, 30);
                                
                                // AI thinking visualization
                                const centerX = 210;
                                const centerY = 80;
                                
                                // Pulsing circles
                                for (let i = 0; i < 3; i++) {
                                    const phase = (animationFrame + i * 20) % 60;
                                    const radius = 20 + phase;
                                    const opacity = 1 - (phase / 60);
                                    
                                    ctx.strokeStyle = `rgba(33, 150, 243, ${opacity * 0.5})`;
                                    ctx.lineWidth = 2;
                                    ctx.beginPath();
                                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                                    ctx.stroke();
                                }
                                
                                // AI icon
                                ctx.font = '24px sans-serif';
                                ctx.fillStyle = '#2196f3';
                                ctx.textAlign = 'center';
                                ctx.fillText('🤖', centerX, centerY + 8);
                                
                                // Generated code
                                ctx.fillStyle = '#f5f5f5';
                                ctx.strokeStyle = '#9e9e9e';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.roundRect(20, 130, 380, 250, 8);
                                ctx.fill();
                                ctx.stroke();
                                
                                // Code animation
                                ctx.font = '10px JetBrains Mono, monospace';
                                ctx.fillStyle = '#1976d2';
                                const theory = currentTheory();
                                const maxLines = Math.min(theory.code.length, Math.floor((animationFrame % 200) / 15));
                                
                                theory.code.slice(0, maxLines).forEach((line, i) => {
                                    // Syntax highlighting
                                    if (line.includes('class') || line.includes('def')) {
                                        ctx.fillStyle = '#7c4dff';
                                    } else if (line.includes('return')) {
                                        ctx.fillStyle = '#f44336';
                                    } else if (line.includes('#') || line.includes('"""')) {
                                        ctx.fillStyle = '#4caf50';
                                    } else {
                                        ctx.fillStyle = '#202124';
                                    }
                                    
                                    ctx.fillText(line, 30, 150 + i * 18);
                                });
                                
                                // Cursor
                                if (maxLines < theory.code.length) {
                                    const cursorX = 30 + ctx.measureText(theory.code[maxLines].substring(0, (animationFrame % 20))).width;
                                    const cursorY = 150 + maxLines * 18;
                                    
                                    if (animationFrame % 40 < 20) {
                                        ctx.fillStyle = '#202124';
                                        ctx.fillRect(cursorX, cursorY - 12, 2, 14);
                                    }
                                }
                            }
                            
                            function drawTestingPhase() {
                                // Title
                                ctx.font = 'bold 16px Aeonik, sans-serif';
                                ctx.fillStyle = '#00bcd4';
                                ctx.textAlign = 'center';
                                ctx.fillText('Step 3: Testing Theory', 210, 30);
                                
                                // Simulation visualization
                                const centerX = 210;
                                const centerY = 150;
                                const orbitRadius = 80;
                                
                                // Black hole
                                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 20);
                                gradient.addColorStop(0, '#000000');
                                gradient.addColorStop(0.7, '#37474f');
                                gradient.addColorStop(1, '#90a4ae');
                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Orbit
                                const angle = (animationFrame % 360) * Math.PI / 180;
                                const particleX = centerX + orbitRadius * Math.cos(angle);
                                const particleY = centerY + orbitRadius * Math.sin(angle) * 0.6;
                                
                                // Trail
                                ctx.strokeStyle = 'rgba(0, 188, 212, 0.3)';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                for (let i = 0; i < 50; i++) {
                                    const trailAngle = angle - (i * 0.1);
                                    const trailX = centerX + orbitRadius * Math.cos(trailAngle);
                                    const trailY = centerY + orbitRadius * Math.sin(trailAngle) * 0.6;
                                    if (i === 0) ctx.moveTo(trailX, trailY);
                                    else ctx.lineTo(trailX, trailY);
                                }
                                ctx.stroke();
                                
                                // Particle
                                ctx.fillStyle = '#ffd700';
                                ctx.beginPath();
                                ctx.arc(particleX, particleY, 5, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Stats
                                ctx.fillStyle = '#f5f5f5';
                                ctx.strokeStyle = '#9e9e9e';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.roundRect(20, 250, 180, 100, 8);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.font = '11px Aeonik, sans-serif';
                                ctx.fillStyle = '#202124';
                                ctx.textAlign = 'left';
                                ctx.fillText('Integration steps: ' + Math.floor((animationFrame % 100) * 1000), 30, 270);
                                ctx.fillText('Time: ' + ((animationFrame % 100) / 10).toFixed(1) + 's', 30, 290);
                                ctx.fillText('r/RS: ' + (2 + Math.sin(angle)).toFixed(2), 30, 310);
                                ctx.fillText('Energy: -0.4523', 30, 330);
                                
                                // FFT visualization
                                ctx.fillStyle = '#f5f5f5';
                                ctx.strokeStyle = '#9e9e9e';
                                ctx.beginPath();
                                ctx.roundRect(220, 250, 180, 100, 8);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.font = '11px Aeonik, sans-serif';
                                ctx.fillStyle = '#00bcd4';
                                ctx.fillText('FFT Analysis', 310, 270);
                                
                                // FFT bars
                                ctx.fillStyle = '#00bcd4';
                                for (let i = 0; i < 8; i++) {
                                    const height = 20 + 30 * Math.sin((animationFrame + i * 10) * 0.05);
                                    ctx.fillRect(240 + i * 18, 320 - height, 12, height);
                                }
                            }
                            
                            function drawResultPhase() {
                                // Title
                                ctx.font = 'bold 16px Aeonik, sans-serif';
                                ctx.fillStyle = '#4caf50';
                                ctx.textAlign = 'center';
                                ctx.fillText('Step 4: Results & Reward', 210, 30);
                                
                                const theory = currentTheory();
                                
                                // Theory summary
                                ctx.fillStyle = '#f5f5f5';
                                ctx.strokeStyle = '#9e9e9e';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.roundRect(20, 60, 380, 80, 8);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.font = 'bold 14px Aeonik, sans-serif';
                                ctx.fillStyle = '#202124';
                                ctx.textAlign = 'left';
                                ctx.fillText(theory.name, 30, 85);
                                
                                ctx.font = '12px Aeonik, sans-serif';
                                ctx.fillStyle = '#5f6368';
                                ctx.fillText(theory.idea, 30, 105);
                                
                                ctx.font = 'bold 16px Aeonik, sans-serif';
                                ctx.fillStyle = theory.loss < 0.3 ? '#4caf50' : '#f44336';
                                ctx.textAlign = 'right';
                                ctx.fillText('Loss: ' + theory.loss.toFixed(3), 380, 105);
                                
                                // Comparison chart
                                ctx.fillStyle = '#f5f5f5';
                                ctx.strokeStyle = '#9e9e9e';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.roundRect(20, 160, 380, 180, 8);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.font = '12px Aeonik, sans-serif';
                                ctx.fillStyle = '#202124';
                                ctx.textAlign = 'center';
                                ctx.fillText('Loss Comparison', 210, 185);
                                
                                // Bars
                                const baselines = [
                                    { name: 'Schwarzschild', loss: 0.000, color: '#2196f3' },
                                    { name: 'Reissner-N', loss: 0.000, color: '#ff9800' },
                                    { name: 'This Theory', loss: theory.loss, color: theory.loss < 0.3 ? '#4caf50' : '#f44336' }
                                ];
                                
                                baselines.forEach((baseline, i) => {
                                    const barX = 80 + i * 100;
                                    const barWidth = 60;
                                    const barHeight = baseline.loss * 100;
                                    
                                    // Bar
                                    ctx.fillStyle = baseline.color;
                                    ctx.fillRect(barX, 280 - barHeight, barWidth, barHeight);
                                    
                                    // Label
                                    ctx.font = '10px Aeonik, sans-serif';
                                    ctx.fillStyle = '#5f6368';
                                    ctx.textAlign = 'center';
                                    ctx.fillText(baseline.name, barX + barWidth/2, 295);
                                    
                                    // Value
                                    ctx.font = 'bold 11px Aeonik, sans-serif';
                                    ctx.fillStyle = baseline.color;
                                    ctx.fillText(baseline.loss.toFixed(3), barX + barWidth/2, 275 - barHeight);
                                });
                                
                                // Reward calculation
                                ctx.fillStyle = theory.loss < 0.3 ? '#e8f5e9' : '#ffebee';
                                ctx.strokeStyle = theory.loss < 0.3 ? '#4caf50' : '#f44336';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.roundRect(20, 360, 380, 60, 8);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.font = 'bold 14px Aeonik, sans-serif';
                                ctx.fillStyle = theory.loss < 0.3 ? '#2e7d32' : '#c62828';
                                ctx.textAlign = 'center';
                                const reward = -theory.loss + (theory.loss < 0.3 ? 0.5 : 0);
                                ctx.fillText('Reward: ' + reward.toFixed(3), 210, 385);
                                
                                ctx.font = '11px Aeonik, sans-serif';
                                ctx.fillStyle = '#5f6368';
                                ctx.fillText(theory.loss < 0.3 ? 'Promising! Continue this direction.' : 'Poor performance. Try different approach.', 210, 405);
                            }
                            
                            function animate() {
                                if (isPaused) return;
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                // Draw current phase
                                switch (generationPhase) {
                                    case 0:
                                        drawPromptPhase();
                                        break;
                                    case 1:
                                        drawGeneratingPhase();
                                        break;
                                    case 2:
                                        drawTestingPhase();
                                        break;
                                    case 3:
                                        drawResultPhase();
                                        break;
                                }
                                
                                // Phase indicator
                                const phaseNames = ['Prompt', 'Generate', 'Test', 'Result'];
                                const phaseWidth = 90;
                                const startX = (canvas.width - phaseWidth * 4) / 2;
                                
                                phaseNames.forEach((name, i) => {
                                    const x = startX + i * phaseWidth + phaseWidth/2;
                                    const y = 470;
                                    
                                    // Circle
                                    ctx.fillStyle = i === generationPhase ? '#1976d2' : (i < generationPhase ? '#4caf50' : '#e0e0e0');
                                    ctx.beginPath();
                                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Number
                                    ctx.font = 'bold 11px Aeonik, sans-serif';
                                    ctx.fillStyle = '#ffffff';
                                    ctx.textAlign = 'center';
                                    ctx.fillText(i + 1, x, y + 4);
                                    
                                    // Label
                                    ctx.font = '10px Aeonik, sans-serif';
                                    ctx.fillStyle = i === generationPhase ? '#1976d2' : '#5f6368';
                                    ctx.fillText(name, x, y + 25);
                                    
                                    // Connector
                                    if (i < phaseNames.length - 1) {
                                        ctx.strokeStyle = i < generationPhase ? '#4caf50' : '#e0e0e0';
                                        ctx.lineWidth = 2;
                                        ctx.beginPath();
                                        ctx.moveTo(x + 12, y);
                                        ctx.lineTo(x + phaseWidth - 12, y);
                                        ctx.stroke();
                                    }
                                });
                                
                                // Update animation
                                animationFrame++;
                                if (animationFrame % 250 === 0) {
                                    generationPhase = (generationPhase + 1) % 4;
                                    if (generationPhase === 0) {
                                        currentTheoryIndex++;
                                    }
                                }
                                
                                requestAnimationFrame(animate);
                            }
                            
                            // Start animation
                            animate();
                        })();
                    </script>
                    
                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">2.1 Key Technical Details</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">📊 Automatic Differentiation</h4>
                            <p class="text-sm lg:text-base">
                                Christoffel symbols Γ^λ_μν computed via PyTorch autograd from metric tensor. No manual derivatives needed.
                            </p>
                            <pre class="mt-2 text-xs bg-white p-2 rounded border"><code>(dV_dr,) = torch.autograd.grad(V_sq, r_grad)</code></pre>
                        </div>
                        
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">🔬 History-Dependent Policy</h4>
                            <p class="text-sm lg:text-base">
                                Each generation includes full history of previous theories and their losses, enabling the LLM to learn patterns.
                            </p>
                            <pre class="mt-2 text-xs bg-white p-2 rounded border"><code>prompt += f"{name}: {summary}, loss={loss:.3e}\n"</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Section 3: Self-Discovery Implementation -->
                <section class="section scroll-mt-20" id="self-discovery">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        3. The self_discovery.py Implementation
                    </h2>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                        <div class="space-y-6">
                            <p class="text-base lg:text-lg leading-relaxed">
                                The core RL loop is implemented in `self_discovery.py`, which orchestrates the entire discovery process:
                            </p>
                            
                            <pre class="bg-gray-50 p-4 rounded-lg text-xs overflow-x-auto"><code>def run_discovery_loop():
    history = []
    for iteration in range(max_iterations):
        # 1. Build prompt with history
        prompt = build_prompt(history)
        
        # 2. Generate new theory (AI action)
        new_theories = generate_new_theories(history, prompt)
        
        # 3. Test in environment
        for theory_code in new_theories:
            result = test_theory(theory_code)
            
        # 4. Update history (state transition)
        history.append({
            'theory': theory_code,
            'loss': result['loss'],
            'reward': -result['loss']
        })
</code></pre>
                            
                            <p class="text-base lg:text-lg leading-relaxed">
                                Key features:
                            </p>
                            <ul class="list-disc list-inside space-y-2 text-sm lg:text-base">
                                <li>Dynamic prompt construction from full history</li>
                                <li>Parallel theory evaluation on GPU</li>
                                <li>Automatic caching of results</li>
                                <li>Human theory injection via --manual-theories-file</li>
                            </ul>
                        </div>
                        
                        <div class="lg:sticky lg:top-8">
                            <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                <canvas id="codeStructureCanvas" class="w-full" width="420" height="500"></canvas>
                                <p class="text-sm text-center text-physics-gray mt-4">self_discovery.py Architecture: The RL control flow. Click to explore.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Code structure visualization -->
                    <script>
                        (function() {
                            const canvas = document.getElementById('codeStructureCanvas');
                            const ctx = canvas.getContext('2d');
                            let animationFrame = 0;
                            let isPaused = false;
                            let hoveredFunction = null;
                            let dataFlow = [];
                            
                            // Initialize data flow particles
                            for (let i = 0; i < 20; i++) {
                                dataFlow.push({
                                    x: Math.random() * canvas.width,
                                    y: Math.random() * canvas.height,
                                    vx: (Math.random() - 0.5) * 0.3,
                                    vy: Math.random() * 0.5 + 0.1,
                                    size: Math.random() * 2 + 1
                                });
                            }
                            
                            canvas.addEventListener('click', () => {
                                isPaused = !isPaused;
                                if (!isPaused) animate();
                            });
                            
                            canvas.addEventListener('mousemove', (e) => {
                                const rect = canvas.getBoundingClientRect();
                                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                                
                                hoveredFunction = null;
                                functions.forEach(func => {
                                    if (x >= func.x && x <= func.x + func.width &&
                                        y >= func.y && y <= func.y + func.height) {
                                        hoveredFunction = func;
                                        canvas.style.cursor = 'pointer';
                                        return;
                                    }
                                });
                                if (!hoveredFunction) {
                                    canvas.style.cursor = 'default';
                                }
                            });
                            
                            // Add roundRect polyfill
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                            const functions = [
                                {
                                    name: 'build_prompt()',
                                    x: 60, y: 50, width: 300, height: 60,
                                    color: '#1976d2',
                                    description: 'Constructs dynamic prompt from history',
                                    code: 'prompt = f"Previous: {history}\\nGenerate new..."'
                                },
                                {
                                    name: 'generate_new_theories()',
                                    x: 60, y: 130, width: 300, height: 60,
                                    color: '#2196f3',
                                    description: 'Calls Grok-4 API with prompt',
                                    code: 'response = client.chat.completions.create(...)'
                                },
                                {
                                    name: 'extract_python_code()',
                                    x: 60, y: 210, width: 300, height: 60,
                                    color: '#00bcd4',
                                    description: 'Parses Python from API response',
                                    code: 'code_blocks = re.findall(r"```python(.*?)```", ...)'
                                },
                                {
                                    name: 'test_theory()',
                                    x: 60, y: 290, width: 300, height: 60,
                                    color: '#4caf50',
                                    description: 'Runs physics simulation',
                                    code: 'loss = simulator.evaluate(theory, baselines)'
                                },
                                {
                                    name: 'update_history()',
                                    x: 60, y: 370, width: 300, height: 60,
                                    color: '#ff9800',
                                    description: 'Appends results for next iteration',
                                    code: 'history.append({"theory": name, "loss": loss})'
                                }
                            ];
                            
                            function drawFunction(func) {
                                const isHovered = hoveredFunction === func;
                                
                                // Function box
                                ctx.fillStyle = isHovered ? func.color : '#f8f9fa';
                                ctx.strokeStyle = func.color;
                                ctx.lineWidth = isHovered ? 3 : 1;
                                
                                if (isHovered) {
                                    ctx.shadowColor = func.color;
                                    ctx.shadowBlur = 10;
                                }
                                
                                ctx.beginPath();
                                ctx.roundRect(func.x, func.y, func.width, func.height, 8);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.shadowBlur = 0;
                                
                                // Function name
                                ctx.font = 'bold 14px JetBrains Mono, monospace';
                                ctx.fillStyle = isHovered ? '#ffffff' : func.color;
                                ctx.textAlign = 'left';
                                ctx.fillText(func.name, func.x + 15, func.y + 25);
                                
                                // Description
                                ctx.font = '12px Aeonik, sans-serif';
                                ctx.fillStyle = isHovered ? 'rgba(255,255,255,0.9)' : '#5f6368';
                                ctx.fillText(func.description, func.x + 15, func.y + 45);
                                
                                // Show code snippet on hover
                                if (isHovered && func.code) {
                                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                                    ctx.strokeStyle = '#ffffff';
                                    ctx.lineWidth = 1;
                                    const codeX = func.x + func.width + 10;
                                    const codeY = func.y;
                                    const codeWidth = 350;
                                    const codeHeight = 50;
                                    
                                    // Adjust position if too far right
                                    const adjustedX = codeX + codeWidth > canvas.width - 10 ? 
                                                     func.x - codeWidth - 10 : codeX;
                                    
                                    ctx.beginPath();
                                    ctx.roundRect(adjustedX, codeY, codeWidth, codeHeight, 5);
                                    ctx.fill();
                                    ctx.stroke();
                                    
                                    ctx.font = '11px JetBrains Mono, monospace';
                                    ctx.fillStyle = '#ffffff';
                                    ctx.fillText(func.code, adjustedX + 10, codeY + 30);
                                }
                            }
                            
                            function drawConnections() {
                                // Draw flow between functions
                                for (let i = 0; i < functions.length - 1; i++) {
                                    const from = functions[i];
                                    const to = functions[i + 1];
                                    
                                    const startX = from.x + from.width / 2;
                                    const startY = from.y + from.height;
                                    const endX = to.x + to.width / 2;
                                    const endY = to.y;
                                    
                                    // Animated dashed line
                                    ctx.strokeStyle = '#9e9e9e';
                                    ctx.lineWidth = 2;
                                    ctx.setLineDash([5, 5]);
                                    ctx.lineDashOffset = -animationFrame * 0.2;
                                    
                                    ctx.beginPath();
                                    ctx.moveTo(startX, startY);
                                    ctx.lineTo(endX, endY);
                                    ctx.stroke();
                                    
                                    ctx.setLineDash([]);
                                    
                                    // Arrow
                                    const angle = Math.atan2(endY - startY, endX - startX);
                                    ctx.save();
                                    ctx.translate(endX, endY);
                                    ctx.rotate(angle - Math.PI/2);
                                    ctx.fillStyle = '#9e9e9e';
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);
                                    ctx.lineTo(-5, -8);
                                    ctx.lineTo(5, -8);
                                    ctx.closePath();
                                    ctx.fill();
                                    ctx.restore();
                                }
                                
                                // Loop back from last to first
                                const last = functions[functions.length - 1];
                                const first = functions[0];
                                
                                ctx.strokeStyle = '#9c27b0';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([5, 5]);
                                ctx.lineDashOffset = -animationFrame * 0.2;
                                
                                ctx.beginPath();
                                ctx.moveTo(last.x + last.width, last.y + last.height/2);
                                ctx.quadraticCurveTo(
                                    400, last.y + last.height/2,
                                    400, (last.y + first.y) / 2
                                );
                                ctx.quadraticCurveTo(
                                    400, first.y + first.height/2,
                                    first.x + first.width, first.y + first.height/2
                                );
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // Loop label
                                ctx.font = 'bold 11px Aeonik, sans-serif';
                                ctx.fillStyle = '#9c27b0';
                                ctx.textAlign = 'center';
                                ctx.fillText('RL LOOP', 400, (last.y + first.y) / 2);
                            }
                            
                            function drawDataFlow() {
                                dataFlow.forEach(particle => {
                                    // Update position
                                    particle.x += particle.vx;
                                    particle.y += particle.vy;
                                    
                                    // Wrap around
                                    if (particle.x < 0) particle.x = canvas.width;
                                    if (particle.x > canvas.width) particle.x = 0;
                                    if (particle.y > canvas.height) {
                                        particle.y = 0;
                                        particle.x = 60 + Math.random() * 300;
                                    }
                                    
                                    // Draw particle
                                    ctx.fillStyle = 'rgba(66, 133, 244, 0.3)';
                                    ctx.beginPath();
                                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                                    ctx.fill();
                                });
                            }
                            
                            function drawTitle() {
                                ctx.font = 'bold 16px Aeonik, sans-serif';
                                ctx.fillStyle = '#1a0dab';
                                ctx.textAlign = 'center';
                                ctx.fillText('self_discovery.py Control Flow', 210, 25);
                            }
                            
                            function animate() {
                                if (isPaused) return;
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                drawTitle();
                                drawDataFlow();
                                drawConnections();
                                
                                // Draw all functions
                                functions.forEach(func => {
                                    drawFunction(func);
                                });
                                
                                animationFrame++;
                                requestAnimationFrame(animate);
                            }
                            
                            // Start animation
                            animate();
                        })();
                    </script>
                    
                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">3.1 The Complete Pipeline</h3>
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                        <ol class="list-decimal list-inside space-y-3 text-base lg:text-lg">
                            <li><strong>Initialization:</strong> Load baselines (Schwarzschild, Reissner-Nordström)</li>
                            <li><strong>History Building:</strong> Accumulate all previous theories and their losses</li>
                            <li><strong>Prompt Engineering:</strong> Construct context-aware prompt with Einstein's insights</li>
                            <li><strong>Theory Generation:</strong> AI generates complete Python class implementing get_metric()</li>
                            <li><strong>Code Validation:</strong> Ensure proper inheritance and method signatures</li>
                            <li><strong>Physics Simulation:</strong> Run 10^5 integration steps, compute FFT loss</li>
                            <li><strong>Reward Assignment:</strong> -loss + bonus for balanced baseline performance</li>
                            <li><strong>State Update:</strong> Append to history for next iteration</li>
                        </ol>
                    </div>
                </section>

                <!-- Section 4: The Prediction Pipeline -->
                <section class="section scroll-mt-20" id="prediction-game">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        4. The Prediction Pipeline: Idea → Theory → Observation → Prediction → Future
                    </h2>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                        <div class="space-y-6">
                            <p class="text-base lg:text-lg leading-relaxed">
                                Every theory follows a rigorous pipeline from initial concept to validated predictions:
                            </p>
                            
                            <ol class="list-decimal list-inside space-y-4 text-base lg:text-lg">
                                <li><strong>Idea:</strong> AI generates concept based on Einstein's notes + history</li>
                                <li><strong>Theory:</strong> Translates idea into executable Python metric</li>
                                <li><strong>Observation:</strong> Simulates 10^5+ geodesic steps</li>
                                <li><strong>Prediction:</strong> Tests against known phenomena (Mercury, pulsars)</li>
                                <li><strong>Future:</strong> Makes novel predictions for unexplained anomalies</li>
                            </ol>
                            
                            <div class="bg-blue-50 border-l-4 border-physics-blue p-6 rounded-r-lg">
                                <p class="font-semibold text-physics-blue mb-2">Example Flow:</p>
                                <p class="text-sm">
                                    Idea: "Add torsion g_tφ" → Theory: TorsionGravity class → 
                                    Observation: Orbit simulations → Prediction: Mercury 42.98"/century → 
                                    Future: Pulsar glitch at 10^-15 scale
                                </p>
                            </div>
                        </div>
                        
                        <div class="lg:sticky lg:top-8">
                            <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                <canvas id="predictionPipelineCanvas" class="w-full" width="420" height="600"></canvas>
                                <p class="text-sm text-center text-physics-gray mt-4">The Complete Prediction Pipeline. Click to animate.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Prediction pipeline animation -->
                    <script>
                        (function() {
                            const canvas = document.getElementById('predictionPipelineCanvas');
                            const ctx = canvas.getContext('2d');
                            let animationFrame = 0;
                            let isPaused = false;
                            let currentStage = 0;
                            let theoryData = null;
                            
                            canvas.addEventListener('click', () => {
                                isPaused = !isPaused;
                                if (!isPaused) animate();
                            });
                            
                            // Add roundRect polyfill
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                            const stages = [
                                {
                                    name: "IDEA",
                                    color: "#1a73e8",
                                    icon: "💡",
                                    content: "Non-symmetric metric with torsion",
                                    detail: "g_μν ≠ g_νμ, add g_tφ term"
                                },
                                {
                                    name: "THEORY",
                                    color: "#2196f3",
                                    icon: "📝",
                                    content: "class TorsionGravity(GravitationalTheory)",
                                    detail: "def get_metric(): return g_tt, g_rr, g_pp, g_tp"
                                },
                                {
                                    name: "OBSERVATION",
                                    color: "#00bcd4",
                                    icon: "🔭",
                                    content: "Geodesic integration",
                                    detail: "100,000 steps, RK4, FFT analysis"
                                },
                                {
                                    name: "PREDICTION",
                                    color: "#4caf50",
                                    icon: "✓",
                                    content: "Mercury: 42.98\"/century",
                                    detail: "Within 0.02\" of observed 43.00\""
                                },
                                {
                                    name: "FUTURE",
                                    color: "#ff9800",
                                    icon: "🚀",
                                    content: "Pulsar timing residual",
                                    detail: "Predicts 10^-15 s anomaly at periastron"
                                }
                            ];
                            
                            function drawStage(index) {
                                const stage = stages[index];
                                const y = 100 + index * 100;
                                const x = 60;
                                const width = 300;
                                const height = 80;
                                const isActive = currentStage >= index;
                                const isCurrent = currentStage === index;
                                
                                // Connection to next stage
                                if (index < stages.length - 1 && isActive) {
                                    ctx.strokeStyle = stage.color;
                                    ctx.lineWidth = 2;
                                    ctx.setLineDash([5, 5]);
                                    ctx.lineDashOffset = -animationFrame * 0.3;
                                    
                                    ctx.beginPath();
                                    ctx.moveTo(x + width/2, y + height);
                                    ctx.lineTo(x + width/2, y + 100);
                                    ctx.stroke();
                                    
                                    ctx.setLineDash([]);
                                    
                                    // Arrow
                                    ctx.fillStyle = stage.color;
                                    ctx.beginPath();
                                    ctx.moveTo(x + width/2, y + 100);
                                    ctx.lineTo(x + width/2 - 5, y + 90);
                                    ctx.lineTo(x + width/2 + 5, y + 90);
                                    ctx.closePath();
                                    ctx.fill();
                                }
                                
                                // Stage box
                                ctx.fillStyle = isActive ? stage.color : '#f8f9fa';
                                ctx.strokeStyle = stage.color;
                                ctx.lineWidth = isCurrent ? 3 : 1;
                                
                                if (isCurrent) {
                                    ctx.shadowColor = stage.color;
                                    ctx.shadowBlur = 15;
                                }
                                
                                ctx.beginPath();
                                ctx.roundRect(x, y, width, height, 10);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.shadowBlur = 0;
                                
                                // Icon
                                ctx.font = '24px sans-serif';
                                ctx.fillStyle = isActive ? '#ffffff' : stage.color;
                                ctx.textAlign = 'center';
                                ctx.fillText(stage.icon, x + 40, y + 45);
                                
                                // Stage name
                                ctx.font = 'bold 14px Aeonik, sans-serif';
                                ctx.fillStyle = isActive ? '#ffffff' : stage.color;
                                ctx.textAlign = 'left';
                                ctx.fillText(stage.name, x + 70, y + 30);
                                
                                // Content
                                ctx.font = '12px JetBrains Mono, monospace';
                                ctx.fillStyle = isActive ? 'rgba(255,255,255,0.9)' : '#202124';
                                ctx.fillText(stage.content, x + 70, y + 48);
                                
                                // Detail
                                ctx.font = '10px Aeonik, sans-serif';
                                ctx.fillStyle = isActive ? 'rgba(255,255,255,0.7)' : '#5f6368';
                                ctx.fillText(stage.detail, x + 70, y + 63);
                                
                                // Progress bar for current stage
                                if (isCurrent) {
                                    const progressWidth = width - 20;
                                    const progressX = x + 10;
                                    const progressY = y + height - 10;
                                    
                                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                                    ctx.fillRect(progressX, progressY, progressWidth, 4);
                                    
                                    const fillWidth = progressWidth * ((animationFrame % 100) / 100);
                                    ctx.fillStyle = '#ffffff';
                                    ctx.fillRect(progressX, progressY, fillWidth, 4);
                                }
                            }
                            
                            function drawVisualization() {
                                // Show stage-specific visualization on the right
                                const vizX = 380;
                                const vizY = 100 + currentStage * 100;
                                
                                switch (currentStage) {
                                    case 0: // IDEA
                                        drawIdeaViz(vizX, vizY);
                                        break;
                                    case 1: // THEORY
                                        drawTheoryViz(vizX, vizY);
                                        break;
                                    case 2: // OBSERVATION
                                        drawObservationViz(vizX, vizY);
                                        break;
                                    case 3: // PREDICTION
                                        drawPredictionViz(vizX, vizY);
                                        break;
                                    case 4: // FUTURE
                                        drawFutureViz(vizX, vizY);
                                        break;
                                }
                            }
                            
                            function drawIdeaViz(x, y) {
                                // Einstein's equation
                                ctx.font = 'italic 14px Georgia, serif';
                                ctx.fillStyle = '#1a73e8';
                                ctx.textAlign = 'center';
                                ctx.fillText('g_tφ = α(rs/r)²', x, y + 20);
                                
                                // Pulsing effect
                                const pulse = Math.sin(animationFrame * 0.05) * 0.3 + 0.7;
                                ctx.globalAlpha = pulse;
                                ctx.strokeStyle = '#1a73e8';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.arc(x, y + 10, 30, 0, Math.PI * 2);
                                ctx.stroke();
                                ctx.globalAlpha = 1;
                            }
                            
                            function drawTheoryViz(x, y) {
                                // Mini code snippet
                                ctx.fillStyle = 'rgba(33, 150, 243, 0.1)';
                                ctx.fillRect(x - 30, y - 20, 60, 40);
                                
                                ctx.font = '8px JetBrains Mono, monospace';
                                ctx.fillStyle = '#2196f3';
                                ctx.textAlign = 'left';
                                ctx.fillText('g_tt = -(1-rs/r)', x - 25, y - 5);
                                ctx.fillText('g_tp = α*(rs/r)²', x - 25, y + 5);
                                ctx.fillText('return g_tt, ...', x - 25, y + 15);
                            }
                            
                            function drawObservationViz(x, y) {
                                // Mini orbit
                                const radius = 20;
                                const angle = (animationFrame % 360) * Math.PI / 180;
                                
                                // Black hole
                                ctx.fillStyle = '#000000';
                                ctx.beginPath();
                                ctx.arc(x, y, 5, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Orbit
                                ctx.strokeStyle = 'rgba(0, 188, 212, 0.3)';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.arc(x, y, radius, 0, Math.PI * 2);
                                ctx.stroke();
                                
                                // Particle
                                const px = x + radius * Math.cos(angle);
                                const py = y + radius * Math.sin(angle);
                                ctx.fillStyle = '#ffd700';
                                ctx.beginPath();
                                ctx.arc(px, py, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            function drawPredictionViz(x, y) {
                                // Check mark with value
                                ctx.strokeStyle = '#4caf50';
                                ctx.lineWidth = 3;
                                ctx.beginPath();
                                ctx.moveTo(x - 15, y);
                                ctx.lineTo(x - 5, y + 10);
                                ctx.lineTo(x + 15, y - 10);
                                ctx.stroke();
                                
                                ctx.font = 'bold 10px Aeonik, sans-serif';
                                ctx.fillStyle = '#4caf50';
                                ctx.textAlign = 'center';
                                ctx.fillText('42.98"', x, y + 25);
                            }
                            
                            function drawFutureViz(x, y) {
                                // Pulsar signal
                                ctx.strokeStyle = '#ff9800';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                for (let i = -30; i <= 30; i += 2) {
                                    const amplitude = i === 0 ? 15 : 5;
                                    const yPos = y + amplitude * Math.sin(i * 0.5 + animationFrame * 0.1);
                                    if (i === -30) ctx.moveTo(x + i, yPos);
                                    else ctx.lineTo(x + i, yPos);
                                }
                                ctx.stroke();
                                
                                ctx.font = '9px Aeonik, sans-serif';
                                ctx.fillStyle = '#ff9800';
                                ctx.textAlign = 'center';
                                ctx.fillText('Δt = 10⁻¹⁵s', x, y + 25);
                            }
                            
                            function drawTitle() {
                                ctx.font = 'bold 18px Aeonik, sans-serif';
                                ctx.fillStyle = '#1a0dab';
                                ctx.textAlign = 'center';
                                ctx.fillText('Complete Theory Pipeline', 210, 40);
                                
                                ctx.font = '12px Aeonik, sans-serif';
                                ctx.fillStyle = '#5f6368';
                                ctx.fillText('From Einstein\'s notes to testable predictions', 210, 60);
                            }
                            
                            function animate() {
                                if (isPaused) return;
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                drawTitle();
                                
                                // Draw all stages
                                for (let i = 0; i < stages.length; i++) {
                                    drawStage(i);
                                }
                                
                                drawVisualization();
                                
                                // Update animation
                                animationFrame++;
                                if (animationFrame % 150 === 0) {
                                    currentStage = (currentStage + 1) % stages.length;
                                }
                                
                                requestAnimationFrame(animate);
                            }
                            
                            // Start animation
                            animate();
                        })();
                    </script>
                </section>

                <!-- Section 5: AI-Generated Theories -->
                <section class="section scroll-mt-20" id="tested-theories">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        5. AI-Generated Theories: What the System Creates
                    </h2>
                    
                    <p class="text-base lg:text-lg leading-relaxed mb-8">
                        The RL system autonomously generates diverse gravitational theories, exploring variations inspired by Einstein's final work and beyond. Each theory is a complete Python implementation of a metric tensor.
                    </p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">Einstein-Inspired</h4>
                            <ul class="text-sm lg:text-base space-y-1">
                                <li>• Non-symmetric g_μν ≠ g_νμ</li>
                                <li>• Torsion fields S^λ_μν</li>
                                <li>• Cross-terms g_tφ</li>
                                <li>• Teleparallel variations</li>
                            </ul>
                        </div>
                        <div class="bg-purple-50 border border-purple-200 rounded-lg p-6">
                            <h4 class="font-semibold text-purple-700 mb-3">Quantum-Motivated</h4>
                            <ul class="text-sm lg:text-base space-y-1">
                                <li>• Planck-scale corrections</li>
                                <li>• Stochastic fluctuations</li>
                                <li>• Discrete spacetime models</li>
                                <li>• Information-theoretic metrics</li>
                            </ul>
                        </div>
                        <div class="bg-green-50 border border-green-200 rounded-lg p-6">
                            <h4 class="font-semibold text-green-700 mb-3">Novel Structures</h4>
                            <ul class="text-sm lg:text-base space-y-1">
                                <li>• Multi-parameter families</li>
                                <li>• Non-local modifications</li>
                                <li>• Energy-dependent metrics</li>
                                <li>• Emergent dimensions</li>
                            </ul>
                        </div>
                    </div>
                    
                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">5.1 Example Generated Theory</h3>
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                        <pre class="text-xs overflow-x-auto"><code class="language-python">class AsymmetricTorsionGravity(GravitationalTheory):
    """AI-generated theory combining Einstein's asymmetric metric with torsion"""
    
    def __init__(self, alpha=0.1, beta=0.05):
        super().__init__('AsymmetricTorsion')
        self.alpha = alpha  # Torsion strength
        self.beta = beta    # Asymmetry parameter
        
    def get_metric(self, r, M, c, G):
        rs = 2 * G * M / c**2
        
        # Schwarzschild base
        g_tt = -(1 - rs/r)
        g_rr = 1/(1 - rs/r)
        g_pp = r**2
        
        # Asymmetric cross-term (Einstein's idea)
        g_tp = self.alpha * (rs/r)**2 * torch.sin(self.beta * r/rs)
        
        return g_tt, g_rr, g_pp, g_tp
</code></pre>
                    </div>
                    
                    <p class="text-base lg:text-lg leading-relaxed mt-6">
                        The AI learns to generate increasingly sophisticated theories based on validation feedback, exploring parameter spaces that would take humans years to investigate manually.
                    </p>
                </section>

                <!-- Section 6: Compression Hypothesis -->
                <section class="section scroll-mt-20" id="compression-hypothesis">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        6. Emergent Hypothesis: Gravity as Information Compression
                    </h2>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 items-start">
                        <div class="space-y-6">
                            <p class="text-base lg:text-lg leading-relaxed">
                                The RL system's exploration revealed a high-reward hypothesis: gravity as an information compression mechanism, mapping high-dimensional quantum states to low-dimensional classical spacetime.
                            </p>
                            <p class="text-base lg:text-lg leading-relaxed">
                                In this view, the metric tensor acts as a decoder, with unification emerging when the same compression structure reproduces both gravitational and electromagnetic effects. The Linear Signal Loss model formalizes this with a degradation parameter γ.
                            </p>
                        </div>
                        
                        <div class="lg:sticky lg:top-8">
                            <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                                <canvas id="compressionHypothesisCanvas" class="w-full" width="420" height="420"></canvas>
                                <p class="text-sm text-center text-physics-gray mt-4">Compression Hypothesis: Laws as information codecs. Click to animate.</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Canvas script (same as before) -->
                    <script>
                        (function() {
                            const canvas = document.getElementById('compressionHypothesisCanvas');
                            const ctx = canvas.getContext('2d');
                            let animationFrame = 0;
                            let isPaused = false;
                            let compressionProgress = 0;
                            let waveOffset = 0;
                            
                            canvas.addEventListener('click', () => {
                                isPaused = !isPaused;
                                if (!isPaused) animate();
                            });
                            
                            // Add roundRect polyfill
                            if (!ctx.roundRect) {
                                ctx.roundRect = function(x, y, width, height, radius) {
                                    ctx.beginPath();
                                    ctx.moveTo(x + radius, y);
                                    ctx.lineTo(x + width - radius, y);
                                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                                    ctx.lineTo(x + width, y + height - radius);
                                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                                    ctx.lineTo(x + radius, y + height);
                                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                                    ctx.lineTo(x, y + radius);
                                    ctx.quadraticCurveTo(x, y, x + radius, y);
                                    ctx.closePath();
                                };
                            }
                            
                            function drawQuantumState(x, y, size) {
                                // Draw complex quantum wavefunction
                                ctx.save();
                                ctx.translate(x, y);
                                
                                // Background circle
                                ctx.fillStyle = '#e8eaf6';
                                ctx.beginPath();
                                ctx.arc(0, 0, size, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Quantum waves
                                ctx.strokeStyle = '#3f51b5';
                                ctx.lineWidth = 1.5;
                                for (let i = 0; i < 5; i++) {
                                    ctx.beginPath();
                                    for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                                        const r = size * 0.5 + 10 * Math.sin(angle * 3 + waveOffset + i);
                                        const x = r * Math.cos(angle);
                                        const y = r * Math.sin(angle);
                                        if (angle === 0) ctx.moveTo(x, y);
                                        else ctx.lineTo(x, y);
                                    }
                                    ctx.closePath();
                                    ctx.globalAlpha = 0.3 - i * 0.05;
                                    ctx.stroke();
                                }
                                ctx.globalAlpha = 1;
                                
                                // Label
                                ctx.fillStyle = '#1a0dab';
                                ctx.font = 'bold 15px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Quantum State', 0, size + 25);
                                ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                ctx.fillStyle = '#5f6368';
                                ctx.fillText('(High-dimensional)', 0, size + 40);
                                
                                ctx.restore();
                            }
                            
                            function drawClassicalSpacetime(x, y, size) {
                                ctx.save();
                                ctx.translate(x, y);
                                
                                // Draw grid representing spacetime
                                ctx.strokeStyle = '#757575';
                                ctx.lineWidth = 1;
                                const gridSize = 15;
                                const halfSize = size;
                                
                                // Grid lines
                                for (let i = -halfSize; i <= halfSize; i += gridSize) {
                                    // Curved grid to show spacetime curvature
                                    ctx.beginPath();
                                    for (let j = -halfSize; j <= halfSize; j += 5) {
                                        const curvature = 20 * Math.exp(-((i*i + j*j) / (halfSize*halfSize)));
                                        if (j === -halfSize) ctx.moveTo(j, i - curvature);
                                        else ctx.lineTo(j, i - curvature);
                                    }
                                    ctx.stroke();
                                    
                                    ctx.beginPath();
                                    for (let j = -halfSize; j <= halfSize; j += 5) {
                                        const curvature = 20 * Math.exp(-((i*i + j*j) / (halfSize*halfSize)));
                                        if (j === -halfSize) ctx.moveTo(i, j - curvature);
                                        else ctx.lineTo(i, j - curvature);
                                    }
                                    ctx.stroke();
                                }
                                
                                // Central mass
                                const gradient = ctx.createRadialGradient(0, -10, 0, 0, -10, 30);
                                gradient.addColorStop(0, '#37474f');
                                gradient.addColorStop(1, '#90a4ae');
                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.arc(0, -10, 15, 0, Math.PI * 2);
                                ctx.fill();
                                
                                // Label
                                ctx.fillStyle = '#1a0dab';
                                ctx.font = 'bold 15px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Classical Spacetime', 0, size + 25);
                                ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                ctx.fillStyle = '#5f6368';
                                ctx.fillText('(4D Observable)', 0, size + 40);
                                
                                ctx.restore();
                            }
                            
                            function drawCompressionArrow(x1, y1, x2, y2, progress) {
                                const dx = x2 - x1;
                                const dy = y2 - y1;
                                const angle = Math.atan2(dy, dx);
                                
                                // Draw wavy arrow representing compression
                                ctx.save();
                                ctx.strokeStyle = '#4caf50';
                                ctx.lineWidth = 3;
                                ctx.setLineDash([5, 5]);
                                ctx.lineDashOffset = -animationFrame * 0.5;
                                
                                ctx.beginPath();
                                for (let t = 0; t <= progress; t += 0.02) {
                                    const x = x1 + dx * t;
                                    const y = y1 + dy * t + 10 * Math.sin(t * 10 + waveOffset);
                                    if (t === 0) ctx.moveTo(x, y);
                                    else ctx.lineTo(x, y);
                                }
                                ctx.stroke();
                                ctx.setLineDash([]);
                                
                                // Arrowhead
                                if (progress > 0.9) {
                                    const endX = x1 + dx * progress;
                                    const endY = y1 + dy * progress;
                                    ctx.translate(endX, endY);
                                    ctx.rotate(angle);
                                    ctx.fillStyle = '#4caf50';
                                    ctx.beginPath();
                                    ctx.moveTo(0, 0);
                                    ctx.lineTo(-15, -8);
                                    ctx.lineTo(-15, 8);
                                    ctx.closePath();
                                    ctx.fill();
                                }
                                ctx.restore();
                                
                                // Label
                                const midX = x1 + dx * 0.5;
                                const midY = y1 + dy * 0.5 - 20;
                                ctx.fillStyle = '#2e7d32';
                                ctx.font = 'bold 13px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('GRAVITY', midX, midY);
                                ctx.font = '11px Aeonik, -apple-system, sans-serif';
                                ctx.fillText('(Compression)', midX, midY + 12);
                            }
                            
                            function drawTheoryBox(x, y) {
                                // Draw theory evaluation box
                                ctx.fillStyle = '#fff3e0';
                                ctx.strokeStyle = '#f57c00';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.roundRect(x - 60, y - 25, 120, 50, 5);
                                ctx.fill();
                                ctx.stroke();
                                
                                ctx.fillStyle = '#e65100';
                                ctx.font = 'bold 13px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Theory g_μν', x, y);
                                ctx.font = '11px Aeonik, -apple-system, sans-serif';
                                ctx.fillText('Decoder', x, y + 12);
                            }
                            
                            function drawLossIndicator(x, y, loss) {
                                // Draw loss meter
                                const width = 100;
                                const height = 20;
                                
                                ctx.fillStyle = '#f5f5f5';
                                ctx.strokeStyle = '#9e9e9e';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.roundRect(x - width/2, y - height/2, width, height, 3);
                                ctx.fill();
                                ctx.stroke();
                                
                                // Fill based on loss
                                const fillWidth = width * (1 - loss);
                                const color = loss < 0.1 ? '#4caf50' : loss < 0.5 ? '#ff9800' : '#f44336';
                                ctx.fillStyle = color;
                                ctx.beginPath();
                                ctx.roundRect(x - width/2, y - height/2, fillWidth, height, 3);
                                ctx.fill();
                                
                                // Label
                                ctx.fillStyle = '#202124';
                                ctx.font = '12px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Decoding Loss', x, y + 25);
                            }
                            
                            function animate() {
                                if (isPaused) return;
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.fillStyle = '#ffffff';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                // Title
                                ctx.fillStyle = '#1a0dab';
                                ctx.font = 'bold 18px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('The Compression Hypothesis', canvas.width / 2, 30);
                                
                                // Update animation states
                                waveOffset += 0.05;
                                compressionProgress = (Math.sin(animationFrame * 0.02) + 1) * 0.5;
                                
                                // Draw components
                                drawQuantumState(100, 100, 50);
                                drawClassicalSpacetime(280, 100, 50);
                                drawCompressionArrow(150, 100, 230, 100, compressionProgress);
                                
                                // Draw theory evaluation
                                drawTheoryBox(190, 220);
                                
                                // Draw loss indicator
                                const loss = 0.1 + 0.4 * (1 - compressionProgress);
                                drawLossIndicator(190, 280, loss);
                                
                                // Information text
                                ctx.fillStyle = '#5f6368';
                                ctx.font = '11px Aeonik, -apple-system, sans-serif';
                                ctx.textAlign = 'center';
                                ctx.fillText('Physical laws = Information codecs', canvas.width / 2, 365);
                                ctx.fillText('Better theory = Lower decoding loss', canvas.width / 2, 380);
                                
                                animationFrame++;
                                requestAnimationFrame(animate);
                            }
                            
                            // Start animation
                            animate();
                        })();
                    </script>
                </section>

                <!-- Section 7: Promising Candidates -->
                <section class="section scroll-mt-20" id="promising-candidates">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        7. Promising Candidates for Unification
                    </h2>
                    <p class="text-base lg:text-lg leading-relaxed mb-8">
                        Our dual-baseline methodology revealed several theories that demonstrate exceptional promise for unifying gravity and electromagnetism. These candidates maintain low loss values against both baselines, indicating potential unified structures.
                    </p>

                    <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                        <!-- Linear Signal Loss (γ=+0.75) -->
                        <div class="bg-white border border-gray-200 rounded-xl shadow-sm hover:shadow-lg transition-shadow duration-300 overflow-hidden">
                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 border-b border-gray-200">
                                <h3 class="text-lg font-semibold text-physics-blue">Linear Signal Loss (γ=+0.75)</h3>
                            </div>
                            <div class="flex gap-2 p-4 bg-gray-50 justify-center">
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+0_75/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+0_75/plot.png" 
                                         alt="Trajectory" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+0_75/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+0_75/metric_plot.png" 
                                         alt="Metric" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                            <div class="p-4 space-y-3">
                                <p class="text-sm font-medium text-physics-blue">
                                    Performance: Loss_GR: 0.153, Loss_RN: 0.161
                                </p>
                                <div class="bg-blue-50 p-3 rounded-lg">
                                    <p class="text-sm font-mono text-center">
                                        <span class="math-var">m = (1 - γ (r_s / r)) × (1 - r_s / r)</span>
                                    </p>
                                </div>
                                <p class="text-sm text-physics-gray italic">
                                    Balanced losses suggest unification through information degradation.
                                </p>
                            </div>
                        </div>

                        <!-- Linear Signal Loss (γ=+1.00) -->
                        <div class="bg-white border border-gray-200 rounded-xl shadow-sm hover:shadow-lg transition-shadow duration-300 overflow-hidden">
                            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 p-4 border-b border-gray-200">
                                <h3 class="text-lg font-semibold text-physics-blue">Linear Signal Loss (γ=+1.00)</h3>
                            </div>
                            <div class="flex gap-2 p-4 bg-gray-50 justify-center">
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+1_00/plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+1_00/plot.png" 
                                         alt="Trajectory" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                                <a href="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+1_00/metric_plot.png" target="_blank" class="w-1/2">
                                    <img src="../../runs/20250710_193244/classical_predefined/promising/20250710_193246_Linear_Signal_Loss_γ_+1_00/metric_plot.png" 
                                         alt="Metric" 
                                         class="w-full h-auto rounded-lg shadow-sm hover:opacity-90 transition-opacity">
                                </a>
                            </div>
                            <div class="p-4 space-y-3">
                                <p class="text-sm font-medium text-physics-blue">
                                    Performance: Loss_GR: 0.133, Loss_RN: 0.133
                                </p>
                                <div class="bg-blue-50 p-3 rounded-lg">
                                    <p class="text-sm font-mono text-center">
                                        <span class="math-var">m = (1 - γ (r_s / r)) × (1 - r_s / r)</span>
                                    </p>
                                </div>
                                <p class="text-sm text-physics-gray italic">
                                    Perfect balance at full degradation indicates robust unification.
                                </p>
                            </div>
                        </div>

                        <!-- Other candidates... (kept but abbreviated for space) -->
                        
                        <!-- AI-Generated Theory Example -->
                        <div class="bg-white border border-gray-200 rounded-xl shadow-sm hover:shadow-lg transition-shadow duration-300 overflow-hidden">
                            <div class="bg-gradient-to-r from-purple-50 to-pink-50 p-4 border-b border-gray-200">
                                <h3 class="text-lg font-semibold text-purple-700">AI: Asymmetric Torsion Theory</h3>
                            </div>
                            <div class="p-4 space-y-3">
                                <p class="text-sm font-medium text-purple-700">
                                    Generated by Grok-4 after analyzing Einstein's notes
                                </p>
                                <div class="bg-purple-50 p-3 rounded-lg">
                                    <p class="text-sm font-mono text-center">
                                        <span class="math-var">g_tφ = α(r_s/r)² sin²θ</span>
                                    </p>
                                </div>
                                <p class="text-sm text-physics-gray italic">
                                    Non-symmetric metric inspired by Einstein's final calculations, showing how AI extends historical insights.
                                </p>
                            </div>
                        </div>
                            </div>
                </section>

                <!-- Interactive Visualization Section -->
                <section class="section scroll-mt-20" id="interactive-viz">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        6. Interactive Visualization System
                    </h2>
                    
                    <p class="text-base lg:text-lg leading-relaxed mb-6">
                        To facilitate deeper exploration and understanding of the generated theories, we have developed an interactive, browser-based 3D visualization system. This tool allows researchers to simulate particle trajectories in real-time under different metrics, adjust parameters on-the-fly, and observe quantum-like effects, all powered by WebGL for GPU acceleration.
                    </p>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-8 mb-4">Key Features</h3>
                    <ul class="list-disc list-inside space-y-3 text-base lg:text-lg mb-8">
                        <li><strong>Real-time Trajectory Simulation:</strong> Visualize multiple particles orbiting a central black hole with dynamic trails showing paths.</li>
                        <li><strong>Parameter Adjustment:</strong> Interactive sliders for theory parameters (e.g., α, γ) and quantum variables (e.g., noise strength for stochastic fluctuations).</li>
                        <li><strong>Quantum Effects:</strong> Simulate energy-based tests with random perturbations to velocities, colored by kinetic energy.</li>
                        <li><strong>Accessibility:</strong> Runs entirely in the browser—no installation required. Supports desktop and mobile devices.</li>
                    </ul>
                    
                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-8 mb-4">How It Works</h3>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        For each evaluated theory, an interactive <code>viz.html</code> file is automatically generated in the theory's run directory. This file loads the central visualization engine and embeds the theory's metric function converted to JavaScript.
                    </p>
                    <p class="text-base lg:text-lg leading-relaxed mb-4">
                        An example visualization for the 'Linear Signal Loss (γ=+1.00)' theory is available at: <a href="../../../viz/example_viz.html" target="_blank" class="text-physics-blue hover:underline font-medium">viz/example_viz.html</a>. Open it in a browser to interact with the simulation.
                    </p>

                    <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg mb-6">
                        <p class="mb-0"><strong>📊 Getting Started:</strong> See the project README.md for detailed instructions on generating and using these visualizations. The source code is in <code>viz/visualization_enhanced.js</code>.</p>
                                </div>
                </section>

                <!-- Black Hole Visualization (kept as is) -->
                <section class="section scroll-mt-20" id="black-hole-visualization">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        7. Interactive Black Hole Demonstration
                    </h2>
                    
                    <p class="text-base lg:text-lg leading-relaxed mb-6">
                        To provide an intuitive understanding of how gravitational theories affect spacetime, we've developed an interactive 3D visualization. This demonstrates how different metric tensors produce different gravitational effects.
                    </p>

                    <div class="bg-blue-50 border-l-4 border-physics-blue p-6 rounded-r-lg mb-8">
                        <h3 class="text-lg font-semibold text-physics-blue mb-3">Key Features of the Visualization:</h3>
                        <ul class="list-disc list-inside space-y-2 text-sm lg:text-base">
                            <li><strong>Dynamic Metrics:</strong> Switch between different AI-generated theories</li>
                            <li><strong>Real-time Integration:</strong> Watch particle trajectories evolve</li>
                            <li><strong>Parameter Control:</strong> Adjust theory parameters α, β, γ on the fly</li>
                            <li><strong>Comparison Mode:</strong> Side-by-side view of different theories</li>
                        </ul>
                        </div>
    
                    <div class="relative w-full" style="padding-bottom: 75%; height: 0; min-height: 700px;">
                        <iframe 
                            src="interactive_black_hole.html" 
                            class="absolute top-0 left-0 w-full h-full border-2 border-gray-300 rounded-lg shadow-lg"
                            style="min-height: 700px;"
                            allow="fullscreen"
                            title="Interactive Black Hole Theory Demonstration">
                        </iframe>
                        </div>
    
                    <div class="mt-8 bg-gray-50 border border-gray-200 rounded-lg p-6">
                        <h3 class="text-lg font-semibold text-physics-dark mb-3">Navigation Instructions:</h3>
                        <ul class="list-disc list-inside space-y-2 text-sm lg:text-base">
                            <li><strong>Rotate:</strong> Click and drag to orbit around the black hole</li>
                            <li><strong>Zoom:</strong> Scroll to approach or retreat</li>
                            <li><strong>Theory Selection:</strong> Use dropdown to switch between AI-generated theories</li>
                        </ul>
                        </div>
    
                    <p class="text-base lg:text-lg leading-relaxed mt-6">
                        For the full immersive experience, <a href="interactive_black_hole.html" target="_blank" class="text-physics-blue hover:underline font-medium">open the visualization in a new tab</a>.
                    </p>
                </section>

                <!-- Contributing Section (kept as is) -->
                <section class="section scroll-mt-20 no-print" id="appendix-e">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        8. Contributing to the Project
                    </h2>
            
                    <div class="bg-blue-50 border-l-4 border-blue-600 p-6 rounded-r-lg mb-8 flex items-center gap-6">
                        <div>
                            <svg class="w-10 h-10 text-blue-500 inline-block mr-3" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4"/>
                            </svg>
                        </div>
                        <div>
                            <h4 class="text-lg font-semibold text-blue-800 mb-1 flex items-center gap-2">
                                <a href="https://github.com/pimdewitte/gravity-compression/" target="_blank" rel="noopener" class="inline-block text-physics-blue hover:underline font-medium">
                                    <svg class="w-5 h-5 inline-block" fill="currentColor" viewBox="0 0 24 24">
                                        <path d="M12 .5C5.73.5.5 5.73.5 12c0 5.08 3.29 9.39 7.86 10.91.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.34-1.3-1.7-1.3-1.7-1.06-.72.08-.71.08-.71 1.17.08 1.78 1.2 1.78 1.2 1.04 1.78 2.73 1.27 3.4.97.11-.75.41-1.27.74-1.56-2.56-.29-5.26-1.28-5.26-5.7 0-1.26.45-2.29 1.19-3.1-.12-.29-.52-1.46.11-3.05 0 0 .98-.31 3.2 1.18a11.1 11.1 0 0 1 2.92-.39c.99.01 1.99.13 2.92.39 2.22-1.49 3.2-1.18 3.2-1.18.63 1.59.23 2.76.11 3.05.74.81 1.19 1.84 1.19 3.1 0 4.43-2.7 5.41-5.27 5.7.42.36.79 1.09.79 2.2 0 1.59-.01 2.87-.01 3.26 0 .31.21.68.8.56C20.71 21.39 24 17.08 24 12c0-6.27-5.23-11.5-12-11.5z"/>
                                    </svg>
                                </a>
                            </h4>
                            <p class="text-sm text-blue-700">
                                The Gravity Compression codebase is <a href="https://github.com/pimdewitte/gravity-compression/" target="_blank" rel="noopener" class="text-physics-blue hover:underline font-medium">available on GitHub</a>.<br>
                            </p>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">🔬 Theory Development</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Propose new metric modifications</li>
                                <li>• Implement theories from literature</li>
                                <li>• Explore parameter spaces</li>
                                <li>• Validate physical constraints</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">💻 Code Improvements</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Optimize geodesic integration</li>
                                <li>• Add new loss metrics</li>
                                <li>• Improve caching system</li>
                                <li>• Enhance visualization tools</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">🤖 AI Enhancement</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Refine discovery prompts</li>
                                <li>• Add new LLM integrations</li>
                                <li>• Improve theory validation</li>
                                <li>• Develop learning algorithms</li>
                            </ul>
                        </div>
                        
                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-6">
                            <h4 class="font-semibold text-physics-blue mb-3">📚 Documentation</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Write tutorials</li>
                                <li>• Document discoveries</li>
                                <li>• Create visualizations</li>
                                <li>• Translate content</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Experimental Validation (kept as is) -->
                <section class="section scroll-mt-20" id="experimental-validation">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        9. Proposed Experimental Validation
                    </h2>
                    
                    <p class="text-base lg:text-lg leading-relaxed mb-6">
                        While our computational framework can test millions of theories, real validation requires comparison with astronomical observations. We propose the following experimental tests:
                    </p>
                    
                    <div class="responsive-table">
                        <table class="w-full border-collapse">
                            <thead>
                                <tr class="bg-gray-50">
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Test ID</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Scientific goal</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Primary datasets</th>
                                    <th class="px-4 py-3 text-left font-semibold text-physics-blue border-b">Pass / fail criterion</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">S-1</td>
                                    <td class="px-4 py-3 border-b">Validate PPN-γ parameter in Linear Signal Loss vs Cassini data</td>
                                    <td class="px-4 py-3 border-b">Cassini radio science</td>
                                    <td class="px-4 py-3 border-b">|γ-1| < 10^{-5} and balanced GR/RN residuals</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">P-1</td>
                                    <td class="px-4 py-3 border-b">Test post-Keplerian parameters in binary pulsar timing</td>
                                    <td class="px-4 py-3 border-b">Hulse-Taylor pulsar</td>
                                    <td class="px-4 py-3 border-b">Energy loss within 0.1% of GR; loss ratio GR/RN >0.9</td>
                                </tr>
                                <tr class="hover:bg-gray-50">
                                    <td class="px-4 py-3 border-b font-medium">P-5</td>
                                    <td class="px-4 py-3 border-b">Analyze GW ringdown for information loss signatures</td>
                                    <td class="px-4 py-3 border-b">LIGO O3 events</td>
                                    <td class="px-4 py-3 border-b">Evidence for γ>0 at >3σ; consistent across events</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">9.1 Testing Predictive Abilities</h3>
                    <p class="text-base lg:text-lg leading-relaxed mb-6">
                        The ultimate test of any theory is its ability to make accurate predictions about unobserved phenomena. To evaluate this, we incorporate various predictive tests into the framework:
                    </p>
                    <ul class="list-disc list-inside space-y-3 text-base lg:text-lg mb-8">
                        <li><strong>Mercury Perihelion Precession:</strong> Predict advance rate and compare to observed 43 arcseconds/century.</li>
                        <li><strong>Gravitational Wave Propagation:</strong> Forecast waveform distortions in LIGO/Virgo events.</li>
                        <li><strong>Black Hole Shadow:</strong> Simulate EHT images for M87* and Sgr A*.</li>
                        <li><strong>Cosmological Parameters:</strong> Predict Hubble constant and dark energy density.</li>
                        <li><strong>Quantum Corrections:</strong> Forecast Hawking radiation spectra for micro black holes.</li>
                    </ul>
                    <p class="text-base lg:text-lg leading-relaxed">
                        These tests use the framework's simulation capabilities to generate predictions, which are then scored against held-out observational data not used in theory generation.
                    </p>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">9.2 The Prediction Pipeline</h3>
                    <p class="text-base lg:text-lg leading-relaxed mb-6">
                        To move from simulation to real-world validation, we follow a structured prediction process:
                    </p>
                    <ol class="list-decimal list-inside space-y-4 text-base lg:text-lg">
                        <li><strong>Idea to Theory:</strong> Any concept expressible as a metric tensor g_μν becomes a testable Python class.</li>
                        <li><strong>Baseline Comparison:</strong> Compute loss against classical (Schwarzschild) and quantum-inspired (Reissner-Nordström) baselines using FFT trajectory analysis. Balanced low losses indicate promise.</li>
                        <li><strong>Promising Theory Logging:</strong> If loss < 0.9 × baseline cross-loss, automatically log to promising_candidates.log.</li>
                        <li><strong>Historical Validation:</strong> Predict known events (e.g., Mercury perihelion) using baselines first, then the new theory. Compare residuals.</li>
                        <li><strong>Future Predictions:</strong> Generate forecasts for unexplained phenomena, like pulsar anomalies not fully captured by GR. Test against public datasets for better fits.</li>
                    </ol>
                </section>

                <!-- Conclusion -->
                <section class="section scroll-mt-20" id="conclusion">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        10. Conclusion: AI-Driven Physics Discovery
                    </h2>
                    
                    <div class="space-y-6 text-base lg:text-lg leading-relaxed">
                        <p>
                            We have demonstrated a complete reinforcement learning system that autonomously generates and tests gravitational theories. The system in `self_discovery.py` implements a true RL loop where an AI agent learns to produce increasingly sophisticated physics based on validation feedback.
                        </p>
                        
                        <p>
                            Key achievements:
                        </p>
                        <ul class="list-disc list-inside space-y-2 ml-4">
                            <li>Fully autonomous theory generation via Grok-4 API</li>
                            <li>GPU-accelerated geodesic simulations (10^6 steps/second)</li>
                            <li>Multi-objective reward system based on astronomical validations</li>
                            <li>History-dependent policy improvement through prompt engineering</li>
                            <li>Complete pipeline: Idea → Theory → Observation → Prediction → Future</li>
                        </ul>
                        
                        <p>
                            The system explores theory spaces inspired by Einstein's final work—non-symmetric metrics, torsion fields, cross-terms—but also ventures into entirely new territories suggested by the AI. Each iteration builds on previous results, creating a self-improving discovery process.
                        </p>
                        
                        <div class="bg-blue-50 border-l-4 border-physics-blue p-6 rounded-r-lg mt-8">
                            <p class="font-semibold text-physics-blue mb-2">The Future of Physics Research</p>
                            <p>
                                This RL approach transforms theoretical physics from a field limited by human intuition to one accelerated by systematic computational exploration. While we cannot replace the deep insights of physicists like Einstein, we can amplify their ideas through AI-driven search, testing millions of variations to find promising candidates for unification.
                            </p>
                        </div>
                        
                        <p>
                            Einstein spent 30 years searching for unified field theory with paper and pencil. Today, our RL system can explore more metric variations in hours than a human could analyze in a lifetime. This isn't about replacing physicists—it's about giving them powerful new tools to tackle the deepest questions in physics.
                        </p>
                    </div>
                </section>

                <!-- Critical Review Section -->
                <section class="section scroll-mt-20" id="critical-review">
                    <h2 class="text-2xl lg:text-3xl xl:text-4xl font-bold text-physics-blue mb-8 pb-4 border-b-2 border-gray-200">
                        11. Critical Review: Accuracy, Limitations, and Reality Check
                    </h2>
                    
                    <div class="bg-amber-50 border-l-4 border-amber-600 p-6 rounded-r-lg mb-8">
                        <p class="font-semibold text-amber-800 mb-2">Important Context</p>
                        <p class="text-sm lg:text-base">
                            While this framework represents significant progress in computational physics, it's crucial to understand its limitations and maintain scientific rigor when interpreting results.
                        </p>
                    </div>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-8 mb-6">11.1 What the Framework Actually Does</h3>
                    <div class="space-y-4 text-base lg:text-lg leading-relaxed">
                        <p>
                            <strong>✓ Accurate:</strong> The framework efficiently tests gravitational theories by simulating particle orbits around black holes and comparing trajectory predictions.
                        </p>
                        <p>
                            <strong>⚠️ Clarification Needed:</strong> "Exploring more theories in hours than Einstein could in decades" is technically true for computational testing, but Einstein's deep mathematical insights and conceptual breakthroughs cannot be reduced to computational throughput.
                        </p>
                        <p>
                            <strong>✗ Overstated:</strong> The framework does not "complete Einstein's quest"—it provides a tool for systematic exploration. True unification requires experimental validation that we don't yet have.
                        </p>
                    </div>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">11.2 Key Limitations</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                        <div class="bg-red-50 border border-red-200 rounded-lg p-6">
                            <h4 class="font-semibold text-red-700 mb-3">⚠️ Validation Scope</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Tests only in strong-field regime (black holes)</li>
                                <li>• No weak-field or cosmological validation</li>
                                <li>• Limited to 2-body orbital dynamics</li>
                                <li>• Cannot test quantum gravity effects directly</li>
                            </ul>
                        </div>
                        
                        <div class="bg-red-50 border border-red-200 rounded-lg p-6">
                            <h4 class="font-semibold text-red-700 mb-3">⚠️ Theoretical Constraints</h4>
                            <ul class="text-sm lg:text-base space-y-2">
                                <li>• Assumes metric theory of gravity</li>
                                <li>• Cannot explore non-geometric approaches</li>
                                <li>• Limited to 4D spacetime (despite 5D claims)</li>
                                <li>• No true quantum field theory integration</li>
                            </ul>
                        </div>
                    </div>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">11.3 Theory Generation Reality Check</h3>
                    <div class="space-y-4 text-base lg:text-lg leading-relaxed">
                        <p>
                            The AI-generated theories show interesting mathematical properties, but several caveats apply:
                        </p>
                        <ul class="list-disc list-inside space-y-2">
                            <li>Generated code is syntactically valid but not guaranteed to be physically meaningful</li>
                            <li>Low computational loss doesn't guarantee physical correctness</li>
                            <li>The theories haven't been tested against precision solar system data</li>
                            <li>No mechanism is provided for why nature would implement these modifications</li>
                        </ul>
                    </div>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">11.4 AI Limitations</h3>
                    <div class="bg-yellow-50 border-l-4 border-yellow-600 p-6 rounded-r-lg">
                        <p class="text-base lg:text-lg mb-3">
                            <strong>The AI doesn't "understand" physics</strong>—it pattern-matches from training data and generates syntactically valid code. Key limitations:
                        </p>
                        <ul class="list-disc list-inside space-y-2 text-sm lg:text-base">
                            <li>Cannot guarantee physical consistency of generated theories</li>
                            <li>May rediscover known theories under different names</li>
                            <li>Biased toward theories similar to training examples</li>
                            <li>Cannot reason about experimental feasibility</li>
                        </ul>
                    </div>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">11.5 What Would Make This Truly Valuable</h3>
                    <div class="space-y-4 text-base lg:text-lg leading-relaxed">
                        <p>
                            To move from interesting computational tool to genuine physics breakthrough, we need:
                        </p>
                        <ol class="list-decimal list-inside space-y-3">
                            <li><strong>Experimental Predictions:</strong> Specific, measurable deviations from GR in upcoming experiments</li>
                            <li><strong>Theoretical Consistency:</strong> Proof that promising theories satisfy energy conditions, causality, etc.</li>
                            <li><strong>Broader Testing:</strong> Extension to cosmological scales, gravitational waves, and weak-field limits</li>
                            <li><strong>Physical Mechanism:</strong> Clear explanation of why nature would implement these modifications</li>
                            <li><strong>Quantum Integration:</strong> True incorporation of quantum field theory, not just classical analogies</li>
                        </ol>
                    </div>

                    <h3 class="text-xl lg:text-2xl font-semibold text-physics-blue mt-12 mb-6">11.6 The Real Value Proposition</h3>
                    <div class="bg-green-50 border-l-4 border-green-600 p-6 rounded-r-lg">
                        <p class="text-base lg:text-lg mb-3">
                            Despite limitations, this framework offers genuine value:
                        </p>
                        <ul class="list-disc list-inside space-y-2 text-sm lg:text-base">
                            <li><strong>Systematic Exploration:</strong> Tests theories that would take years to analyze by hand</li>
                            <li><strong>Open Infrastructure:</strong> Provides reusable tools for gravitational physics research</li>
                            <li><strong>Hypothesis Generation:</strong> Suggests new directions for theoretical investigation</li>
                            <li><strong>Educational Tool:</strong> Helps visualize and understand gravitational theories</li>
                            <li><strong>Community Platform:</strong> Enables collaborative theory development and testing</li>
                        </ul>
                    </div>

                    <div class="mt-8 p-6 bg-gray-50 border border-gray-300 rounded-lg">
                        <p class="text-base lg:text-lg italic text-center text-physics-gray">
                            "The framework is a powerful telescope for exploring theoretical space—but like any telescope, it can only show us where to look, not guarantee what we'll find."
                        </p>
                    </div>
                </section>
                
                <!-- New Horizontal Process Diagram -->
                <div class="mt-12 mb-12">
                    <div class="bg-gray-50 border border-gray-200 rounded-xl p-4 lg:p-6">
                        <canvas id="predictionProcessCanvas" class="w-full" width="840" height="300"></canvas>
                        <p class="text-sm text-center text-physics-gray mt-4">The Prediction and Validation Process: From Idea to Verified Theory. Click to animate.</p>
                    </div>
                </div>

                <script>
                    (function() {
                        const canvas = document.getElementById('predictionProcessCanvas');
                        const ctx = canvas.getContext('2d');
                        let animationFrame = 0;
                        let isPaused = false;
                        let progress = 0;
                        
                        const stages = [
                            { name: '1. Idea to Theory', x: 10, details: 'Express as metric tensor g_μν in Python class' },
                            { name: '2. Baseline Comparison', x: 180, details: 'Compute FFT loss vs GR and RN baselines' },
                            { name: '3. Promising Check', x: 350, details: 'If loss < 0.9 × cross-loss, log as promising' },
                            { name: '4. Historical Validation', x: 520, details: 'Predict known events and compare residuals' },
                            { name: '5. Future Predictions', x: 690, details: 'Forecast unexplained phenomena like pulsar anomalies' }
                        ];
                        
                        canvas.addEventListener('click', () => {
                            isPaused = !isPaused;
                            if (!isPaused) animate();
                        });
                        
                        function drawStage(stage, index) {
                            const y = 100;
                            const width = 140;
                            const height = 80;
                            const isActive = Math.floor(progress) === index;
                            const isPast = progress > index;
                            
                            ctx.fillStyle = isActive ? '#e3f2fd' : (isPast ? '#f8f9fa' : '#ffffff');
                            ctx.strokeStyle = isActive ? '#1976d2' : '#dadce0';
                            ctx.lineWidth = isActive ? 3 : 1;
                            
                            ctx.beginPath();
                            ctx.roundRect(stage.x, y, width, height, 10);
                            ctx.fill();
                            ctx.stroke();
                            
                            ctx.fillStyle = isActive ? '#1976d2' : '#202124';
                            ctx.font = 'bold 12px Aeonik, sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(stage.name, stage.x + width/2, y + 30);
                            
                            ctx.font = '11px Aeonik, sans-serif';
                            ctx.fillStyle = isActive ? '#1976d2' : '#5f6368';
                            const words = stage.details.split(' ');
                            let line = '';
                            let lineY = y + 50;
                            words.forEach(word => {
                                if (line.length + word.length > 18) {
                                    ctx.fillText(line, stage.x + width/2, lineY);
                                    line = word + ' ';
                                    lineY += 15;
                                } else {
                                    line += word + ' ';
                                }
                            });
                            ctx.fillText(line, stage.x + width/2, lineY);
                        }
                        
                        function drawArrow(x1, y1, x2, y2, prog) {
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const currentX = x1 + dx * prog;
                            const currentY = y1 + dy * prog;
                            
                            ctx.strokeStyle = '#616161';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(currentX, currentY);
                            ctx.stroke();
                            
                            if (prog >= 1) {
                                const angle = Math.atan2(dy, dx);
                                ctx.save();
                                ctx.translate(x2, y2);
                                ctx.rotate(angle);
                                ctx.fillStyle = '#616161';
                                ctx.beginPath();
                                ctx.moveTo(0, 0);
                                ctx.lineTo(-10, -5);
                                ctx.lineTo(-10, 5);
                                ctx.closePath();
                                ctx.fill();
                                ctx.restore();
                            }
                        }
                        
                        function animate() {
                            if (isPaused) return;
                            
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            
                            // Title
                            ctx.fillStyle = '#1a0dab';
                            ctx.font = 'bold 18px Aeonik, sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText('Prediction & Validation Process', canvas.width/2, 40);
                            
                            // Draw all stages
                            stages.forEach((stage, index) => {
                                drawStage(stage, index);
                            });
                            
                            // Draw connecting arrows with progress
                            for (let i = 0; i < stages.length - 1; i++) {
                                const arrowProg = Math.max(0, Math.min(1, (progress - i) * 2));
                                drawArrow(stages[i].x + 140, 140, stages[i+1].x, 140, arrowProg);
                            }
                            
                            progress += 0.005;
                            if (progress > stages.length - 1) progress = 0;
                            
                            animationFrame++;
                            requestAnimationFrame(animate);
                        }
                        
                        // Start animation
                        animate();
                    })();
                </script>
            </main>
        </div>
    </div>

    <!-- Scripts (kept as is) -->
    <script>
        // Mobile menu functionality
        const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
        const mobileMenuClose = document.getElementById('mobile-menu-close');
        const mobileMenu = document.getElementById('mobile-menu');
        
        if (mobileMenuToggle) {
            mobileMenuToggle.addEventListener('click', () => {
                mobileMenu.classList.remove('translate-x-full');
            });
        }
        
        if (mobileMenuClose) {
            mobileMenuClose.addEventListener('click', () => {
                mobileMenu.classList.add('translate-x-full');
            });
        }
        
        // Close mobile menu when clicking a link
        document.querySelectorAll('#mobile-menu a').forEach(link => {
            link.addEventListener('click', () => {
                mobileMenu.classList.add('translate-x-full');
            });
        });
        
        // Smooth scroll offset for fixed header
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    const offset = window.innerWidth < 1024 ? 80 : 20; // Different offset for mobile vs desktop
                    const targetPosition = target.offsetTop - offset;
                    window.scrollTo({
                        top: targetPosition,
                        behavior: 'smooth'
                    });
                }
            });
        });
        
        // Active section highlighting in navigation
        const sections = document.querySelectorAll('section[id]');
        const navLinks = document.querySelectorAll('nav a[href^="#"]');
        
        function highlightActiveSection() {
            const scrollY = window.pageYOffset;
            
            sections.forEach(section => {
                const sectionHeight = section.offsetHeight;
                const sectionTop = section.offsetTop - 100;
                const sectionId = section.getAttribute('id');
                
                if (scrollY > sectionTop && scrollY <= sectionTop + sectionHeight) {
                    navLinks.forEach(link => {
                        link.classList.remove('bg-blue-100', 'text-physics-blue', 'font-medium');
                        if (link.getAttribute('href') === `#${sectionId}`) {
                            link.classList.add('bg-blue-100', 'text-physics-blue', 'font-medium');
                        }
                    });
                }
            });
        }
        
        window.addEventListener('scroll', highlightActiveSection);
        highlightActiveSection(); // Initial check
        
        // Responsive table wrapper
        document.querySelectorAll('table').forEach(table => {
            if (!table.closest('.responsive-table')) {
                const wrapper = document.createElement('div');
                wrapper.className = 'responsive-table overflow-x-auto';
                table.parentNode.insertBefore(wrapper, table);
                wrapper.appendChild(table);
                table.className = 'min-w-full border-collapse text-sm lg:text-base';
            }
        });
    </script>
</body>
</html>
